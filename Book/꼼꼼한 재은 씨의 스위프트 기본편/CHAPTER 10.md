# CHAPTER 10 – 테이블 뷰의 동작원리

# 10.1 테이블 뷰를 스크롤 할 때 발생하는 일들

## 10.1.1 재사용 매커니즘(Reuse Mechanism)

- 화면에 나타내야 할 데이터가 아무리 많아도 테이블 뷰는 화면에 당장 표시할 만큼의 셀만 만들고, 나머지는 필요할 때마다 그때그때 생성함. 필요할 때라는 것은 스크롤로 인해 화면에 새로운 셀이 나타나야 할 때. 오직 화면에 더 보여야 하는 딱 그만큼의 셀만 만들어냄. 반면 스크롤로 인해 화면을 벗어나게 된 기존 셀들은 테이블 뷰에서 제거한 후 재사용을 위해 큐에 저장함. 새로운 셀이 필요해지는 시점이 되면 큐에 저장된 셀을 꺼내어 재사용하고, 저장된 셀이 없을 경우 새로 생성함.
- 화면에 새로운 셀을 표시할 때마다 tableView(_:cellForRowAt:) 메소드는 매번 다시 실행됨. 이미 만들어져 화면에 노출된 셀이라도 일단 화면을 벗어나 테이블 뷰에서 제거되고 나면 이 셀을 다시 화면에 표시하기 위해서는 해당 메소드를 거쳐야 함.
- 스크롤 할 때마다 tableView(_:cellForRowAt:) 메소드가 실행되면서 매번 셀의 콘텐츠를 재구성하다 보니, 그때마다 썸네일 이미지를 웹 서버에서 내려받아서 네트워크 통신을 통해 매번 데이터를 읽어 들이며 셀을 구성하는 데 시간이 오래 걸림. 이러한 문제를 피하려면 iOS 개발에 관하여 다음과 같은 프로그래밍 원칙들을 적용해야 함.
    - (1) 반복적으로 호출되는 메소드의 내부에는 네트워크 통신 등 처리 시간이 긴 로직을 포함하지 않아야 함.
    - (2) 네트워크 통신을 통해 읽어온 데이터는 재사용할 수 있도록 캐싱(Caching) 처리하여 될 수 있으면 네트워크 통신 횟수를 줄이는 것이 좋음
    - (3) 네트워크 통신이나 시간이 오래 걸리는 코드를 사용할 때는 비동기(Asynchronize)로 처리하는 것이 바람직함
- (2)번 원칙은 메모이제이션(memorization) 기법으로 프로그램이 동일한 계산을 반복해야 할 때 이전에 계산한 값을 메모리에 저장함으로써 반복 수행을 제거하고 프로그램의 실행 속도를 빠르게 하는 기술이다.
- (2)번 원칙을 적용 → API 호출로부터 읽어온 데이터를 순회화는 과정에서 이미지를 내려받아서 배열에 저장하고, tableView(_:cellForRowAt:) 메소드가 호출될 때는 미리 내려받은 이미지를 사용하는 것
- 위 방식을 적용하면 최초 한 번만 이미지를 내려받을 뿐, 화면을 스크롤 해서 셀이 재구성되어도 이후로는 이미지를 내려받지 않음. 화면이 스크롤이 반복해서 발생하더라도 부드러운 UI를 유지할 수 있음. 하지만 화면을 구성할 때 썸네일 이미지 여러 개를 내려받아야 하므로 초기 화면 로딩이 지연되는 문제가 생김. 그리고 그만큼의 이미지를 메모리에 저장하고 있어야 한다는 부담도 있음.
- 썸네일 이미지를 처음 내려받는 동안은 화면 스크롤이 매끄럽지 못한 이러한 현상을 블로킹(Blocking)이라고 함. 하나의 긴 요청을 처리하는 동안 다른 요청은 처리할 수 없게 되어 앞의 처리가 끝날 때까지 대기 상태가 발생하는 경우이다.

## 10.1.2 이미지 비동기 처리하기

- 동기(Synchronize) 방식이란, 주어진 명령을 차례대로 처리하되 하나의 업무가 완료될 때까지는 다음 업무로 넘어가지 않는 방식을 말함.
- 프로그램에서 비동기 방식의 처리는 긴 시간이 걸릴 것으로 예상하는 기능을 새로운 실행 흐름을 만들어서 실행하는 방식이다. 이를 통해 프로그램 메인 실행 흐름이 아무 영향을 받지 않도록 하여 응답을 대기하는 상황이 발생하지 않게 처리해줌. 이런 구조로 된 프로그래밍을 비동기(Asynchronize) 프로그래밍이라고 함.
- 스위프트에서는 크게 2가지 방식의 비동기 구현 기능을 제공
    - 네트워크 통신 자체에만 국한된 비동기 처리로서 NSURLConnectionDelegate 객체를 이용하는 것. 델리게이트 객체에 이미지 내려받기에 대한 처리를 위임한 다음, 내려받기가 완료되면 델리게이트 객체가 특정 메소드를 호출하게 하여 이 메소드 내부에 처리할 작업을 정의하는 방식으로 구현함
    - 범용 비동기 실행 함수 main.async()를 사용하면 개발자가 내부적으로 프로세스나 쓰레드에 접근하지 않고도 비동기 방식으로 처리를 할 수 있음
- main.async() 함수는 비동기 방식으로 실행할 코드를 함수나 클로저 형식으로 입력받음. 클로저의 특성상 연관된 외부 범위 변수를 그대로 사용할 수 있으므로 인자값으로 전달되지 않은 cell 객체도 내부에서 참조할 수 있음. 실제로 클로저 내부의 코드가 실행되는 시점이 tableView(_:cellForRowAt:) 메소드의 실행이 모두 종료된 후라면 이 메소드 내부에서 선언된 cell 객체도 제거되어야 하지만, 클로저는 내부 함수에서 사용되는 외부 환경을 계속 유지해 주는 특성 때문에 cell 객체가 제거되지 않고 계속 살아있을 수 있음.
- 주의할 점은 비동기 방식으로 처리된 코드는 기존 실행 흐름과 별도로 처리되므로 실행 순서를 보장하지는 못함. 즉, DispatchQueue.main.async() 메소드 내부에 있는 코드가 먼저 작성되었다고 해서 main.async() 다음에 작성된 코드보다 먼저 실행된다는 보장이 없음
- 이 때문에 비동기로 구현된 기능의 결과를 받아 또 다른 무언가를 처리해야 하는 연관된 기능들이 있다면, 이 기능들은 모두 비동기로 분리된 새로운 실행 흐름 내에서 처리하도록 구성해야함.

# 10.2 일반 뷰 컨트롤러에서 테이블 뷰 사용하기

- 스위프트에서는 클래스의 다중 상속을 지원하지 않으므로 UIViewController를 이미 상속받았다면 다른 클래스를 더 상속받을 수는 없음
- UITableViewDataSource, UITableViewDelegate는 클래스가 아닌 프로토콜이고 프로토콜을 추가하는 것은 상속이 아닌 구현 선언의 개념이다.
