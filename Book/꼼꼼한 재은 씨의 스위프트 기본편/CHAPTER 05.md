# CHAPTER 05 – 다른 뷰 컨트롤러와 데이터 주고받기

# 5.1 화면 전환 과정에서의 값 전달 방식

- 뷰 컨트롤러 사이에 값을 주고받는 방식은 두 가지 개념으로 나누어 볼 수 있음
    - 뷰 컨트롤러에서 다음 뷰 컨트롤러로 값을 직접 전달하는 방식
    - 공통 저장소를 만들어 뷰 컨트롤러에서 여기에 값을 저장하고 화면을 이동하면 다음 뷰 컨트롤러에서 이 저장소를 열어 다시 값을 꺼내오는 공유 방식
- 직접 전달 방식(동기 방식)
    - 뷰 컨트롤러에 직접 값을 전달하는 방식은 주로 영속적으로 값을 저장할 필요가 없는 화면 전환에서 사용됨
    - 화면이 전환될 때 데이터가 함께 전달되거나 화면이 전환되기 전에 데이터가 미리 전달되므로 전달 과정에서 값이 누락될 염려가 없다는 장점
    - 화면 전환과 값 전달이 함께 이루어진다는 점에서 편의상 동기 방식이라고 부르겠음
- 간접 전달 방식(비동기 방식)
    - 저장소를 이용하여 값을 전달하는 방식은 주로 지속적으로 값을 저장할 필요가 있는 화면 전환에서 사용됨
    - 값을 계속 사용할 수 있게 저장해 놓는 데에는 좋지만, 저장소에 데이터가 저장되는 시점과 화면 전환 시점이 일치하지 않으면 값 전달이 제대로 안 될 수 있음
    - 저장소를 이용하면 화면이 전환되었음에도 값을 전달받지 못 하는 경우가 생길 수도 있으므로 이에 대한 처리가 필요함
    - 화면 전환과 값의 전달이 따로 이루어진다는 점에서 편의상 비동기 방식이라고 부르겠음
- 동기 방식은 값을 전달받는 쪽의 뷰 컨트롤러가 전달받을 값의 명세를 모두 파악하고 이를 대입할 변수를 미리 생성해 두어야 한다는 단점이 있음
- 비동기 방식은 보내는 쪽과 받는 쪽 모두 저장소의 위치를 사전에 공유하고 있어야 한다는 부담이 있음

# 5.2 뷰 컨트롤러에 직접 값을 전달하기

- 각각의 값을 전달받을 프로퍼티도 동일한 개수가 정의되어야 하고 해당 프로퍼티 타입은 대입할 값의 타입과 정확히 일치해야 함
- 여러 개의 데이터를 주고받아야 할 경우에는 파운데이션 프레임워크에서 제공하는 NSMutableDictionary 같은 집합 자료형을 사용하여 데이터를 주고받는 것이 훨씬 편리함 → 전달할 값의 개수나 타입과 관계없이 변수 하나에 모두 담아서 전달할 수 있기 때문

## 5.2.1 프레젠테이션 방식으로 화면 전환하면서 값을 전달하기

- 액션 메소드를 정의할 때에는 매개변수 타입을 두 가지 방식 중 선택
    - 범용 타입인 Any
    - UI***로 시작하는 개별 타입
- Any 타입으로 선언하면 하나의 액션 메소드를 서로 다른 타입의 컨트롤들이 공용으로 사용할 수 있어 편리하지만 막상 해당 인자값을 사용해야 할 때에는 다시 하위 타입으로 캐스팅해줘야 됨
- 개별 타입으로 선언해 두면 해당 메소드는 이에 맞는 타입의 컨트롤만 호출할 수 있어 제한적이지만, 컨트롤의 속성을 제어하거나 읽어 들여야 할 경우엔 캐스팅할 필요 없이 바로 사용할 수 있음
- 개별 타입을 선택해야 할 때
    - 액션 메소드를 호출한 컨트롤의 속성값이 필요하거나, 이를 제어해야 할 때
- Any 타입을 선택해야 할 때
    - 서로 다른 타입의 컨트롤이 동일한 액션 메소드를 호출하게끔 처리하고 싶을 때
    - 액션 메소드를 호출한 컨트롤의 정보가 필요 없을 때
    - 개별 타입을 반드시 사용해야 하는 경우를 제외한 나머지 모든 경우
- 인자값을 이용해서 무엇인가를 해야 할 때 개별 타입을 사용하고 그 이외에는 그냥 Any 타입으로 지정해 주면 됨
- 발생한 이벤트를 애플리케이션으로 전달해주는 iOS 시스템에 의해, 액션 메소드가 호출될 때 이벤트가 발생한 컨트롤의 정보도 함께 인자값으로 제공됨 → 주로 sender가 이에 해당됨
- 다운 캐스팅(Down Casting)은 상위 클래스를 하위 클래스로 형변환이고 캐스팅 타입을 잘못 지정하면 실패할 가능성이 있어 오류가 발생할 수 있음
- 업 캐스팅(Up Casting)은 하위 클래스를 보다 넓은 범위인 상위 클래스로 캐스팅이고 오류가 발생하지 않음
- 다운 캐스팅은 안전하게 옵셔널 타입으로 캐스팅 결과를 던져줄지, 혹은 강제로 캐스팅하여 일반 타입을 던져줄지 판단해야 함
    - 옵셔널 캐스팅
        - sender as? UISwitch
        - 결과값 : 옵셔널 타입
    - 강제 캐스팅
        - sender as! UISwitch
        - 결과값 : 일반 타입
    - 아울렛 변수는 외부에서 값을 직접 대입할 수 없는 변수인 대신에 시스템에 의해 값이 주입됨
    - 아울렛 변수는 외부 객체에서 직접 참조할 수 없도록 제한되어 있음
    - instantiateViewController(withIdentifier:) 메소드를 호출하여 생성된 인스턴스는 기본적으로 UIViewController 타입임
    - 인스턴스를 UIViewController 타입으로 사용한다면 우리가 추가한 속성 변수를 참조할 수 없음
    - 옵셔널 타입을 일반 타입으로 전환하기 위해 guard 구문 내에서 옵셔널 바인딩 처리
    - 전달받은 값을 화면에 표시하기 위한 가장 적절한 시점은 화면이 메모리에 로드되고 난 직후임
    - 화면이 메모리에 로드되고 난 시점에는 viewDidLoad() 메소드를 호출함
    - 3항 연산자는 A ? B : C라는 형식으로 이루어지는데, A가 참이면 B를, 거짓이면 C를 반환함
    - viewDidLoad() 메소드에 내용을 작성해두면 화면이 메모리에 모두 로드되고 난 후 시스템에 의하여 이 메소드가 호출되면서 메소드 내에 작성해둔 내용도 함께 실행되는데 앱이 화면에 처음 로드될 때 한 번만 호출된다.

## 5.2.2 내비게이션 컨트롤러를 통해 화면 전환하면서 값을 전달하기

- 애플의 UI 지침에 따르면 내비게이션 바를 사용하는 경우 액션 처리 버튼은 가급적 내비게이션 바에 배치하는 것이 좋음
- 화면 전환은 내비게이션 컨트롤러를 이용한 푸시 방식을 사용해야 함

# 5.3 이전 화면으로 값을 전달하기

- 인스턴스 참조를 얻어오는 방식은 VC1 → VC2로 어떻게 전환했는가에 따라 다름.
    - 프레젠테이션 방식이라면 presentingViewController를 사용하여 값을 읽어올 수 있음
    - 내비게이션 컨트롤러 방식이라면 navigationController?.viewControllers 배열 속성을 통해 얻어올 수 있음
- 반대 방향으로 값을 전달하고자 할 때에는 값의 성격을 고려해서 처리해야 함. 소실되어도 상관없는 값이라면 단순히 값을 직접 주고받는 동기방식을 사용하면 되지만, 만약 소실되어서는 안 되는 값이라면 값을 직접 주고받는 대신 값을 보관해둘 수 있는 곳을 찾아 여기에 값을 저장하고, 이전 화면으로 돌아온 후에 값을 꺼내는 식으로 처리할 필요가 있음

## 5.3.2 저장소를 사용하여 값을 주고 받기

- AppDelegate는 UIApplication 객체로부터 생명 주기 관리를 위임받아 커스텀 코드를 처리하는 역할을 함. 하지만 이 객체는 앱 전체를 통틀어 단 하나만 존재하므로 여러 뷰 컨트롤러에서 모두 접근할 수 있고, 앱 프로세스의 생성/소멸과 운명을 함께 하므로 이 객체에 값을 저장하면 앱이 종료되지 않는 한 값을 계속 유지할 수 있음
- 앱이 종료되면 AppDelegate에 저장된 값도 사라져 버리게 됨 → AppDelegate 객체에 저장한 값이 단순히 메모리에만 저장되기 때문임
- 앱이 종료된 후에도 값을 보존하려면 반영구적으로 값을 저장할 수 있는 저장 객체를 사용해야 함.
- 코코아 터치 프레임워크에서는 값을 반영구적으로 저장할 수 있도록 UserDefaults 객체(구 NSUserDefaults 객체)와 코어 데이터(Core Data) 객체를 제공함

### AppDelegate 객체를 사용하여 값을 주고받기

- AppDelegate는 앱 전체를 통틀어 하나의 인스턴스만 존재하도록 iOS 시스템에 의해 보장됨 → 싱글톤(Singleton)
- AppDelegate 클래스의 인스턴스는 직접 생성할 수 없으며, UIApplication.shared.delegate 구문을 통해 현재 생성되어 있는 인스턴스를 참조해야 함
- 경우에 따라서는 AppDelegate 클래스를 대신하는 다른 클래스를 만들어 같은 역할로 사용할 수도 있음. 다음의 몇 가지 원칙만 지켜서 클래스를 생성하면AppDelegate 클래스를 대체할 수 있음
    - (1) UIResponse 클래스를 상속받아야 함
    - (2) UIApplicationDelegate 프로토콜 구현을 선언해야 함
    - (3) @UIApplicationMain 어노테이션을 붙여주어야 → ‘이 클래스를 App Delegate로 선언한다’는 뜻. 따라서 하나의 앱에 @UIApplicationMain 어노테이션은 한 번만 사용되어야 함
- shared.delegate 구문을 통해 앱 델리게이트 인스턴스를 가져온 다음 이를 AppDelegate 타입으로 캐스팅하고 사용하면 됨

### UserDefaults 객체를 사용하여 값을 주고받기

- 코코아 터치 프레임워크에서 제공하는 UserDefaults 객체는 앱을 삭제하기 전까지는 저장된 값이 반영구적으로 유지된다는 장점이 있음
- UserDefaults는 시스템에서 자동으로 생성하여 제공하는 단일 객체이므로, 이 인스턴스는 지금까지의 일반적인 방법처럼 직접 생성하는 것이 아니라 standard 프로퍼티를 사용하여 읽어와야 함
- UserDefaults 객체에는 스위프트의 기본 자료형을 그대로 저장할 수 있으므로 값의 타입을 변경해줄 필요가 없음
- UserDefaults에 저장한 객체는 함께 저장된 키를 통해 구분됨
- let ud = UserDefaults.standard는 UserDefaults의 클래스 프로퍼티인 standard를 사용하여 인스턴스 참조를 가져오는 코드
- 저장된 값을 꺼낼 때는 저장된 값의 타입에 맞는 메소드를 사용하면 읽어온 값을 캐스팅하는 과정 없이 바로 사용할 수 있음
- UserDefaults 객체에서 값을 읽어오는데 아무 값도 저장되어 있지 않으면 nil을 반환함 → 옵셔널 타입을 해제해 주어야 함
- 저장된 값의 타입이 어떤 것인지 정확하게 알기 어렵거나 메소드를 공용으로 사용할 때에는 범용 데이터 타입을 반환하는 메소드를 사용해도 됨. 이 메소드는 Any 타입을 반환하기 때문에 다음과 같은 식으로 캐스팅해서 값을 사용하면 됨
    - let email = UserDefaults.standard.value(forKey: “email”) as? String
    - let email = UserDefaults.standard.object(forKey: “email”) as? String
