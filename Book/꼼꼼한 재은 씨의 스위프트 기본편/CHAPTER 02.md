# CHAPTER 02 - iOS 앱의 구조와 코코아 터치 프레임워크

- 시스템 프레임워크는 iOS 기반의 앱이 실행되는 데에 필요한 기반 환경을 제공하고, 우리는 커스텀 코드를 제공하여 원하는 기능과 앱의 형태를 구현함

# 2.1 앱의 기본 구조

## 2.1.1 엔트리 포인트와 앱의 초기화 과정

- C 언어에 뿌리를 둔 모든 애플리케이션은 main() 함수로부터 시작됨  
→ 엔트리 포인트(Entry Point, 시작 진입점)
- main() 함수는 실행 시 시스템으로부터 전달받은 두 개의 인자값과 AppDelegate 클래스를 이용하여 UIApplicationMain() 함수를 호출하고, 그 결과로 UIApplication 객체를 반환함. 생성된 UIApplication 객체는 UIKit 프레임워크에 속해있으므로 이후의 앱 제어권은 UIKit 프레임워크로 이관됨
- main() 함수가 C 기반 애플리케이션의 엔트리 포인트라면, UIApplicationMain() 함수는 그 중에서 iOS 앱에 속하는 부분의 엔트리 포인트라고 할 수 있음.
- UIApplicationMain() 함수가 생성하는 UIApplication은 앱의 본체라고 할 수 있는 객체로, 사실상 앱 그 자체를 의미함.
- UIApplication 객체는 AppDelegate라는 대리인, 아니 대리 객체를 내세우고 커스텀 코드를 처리할 수 있도록 약간의 권한을 부여함. AppDelegate는 UIApplication으로부터 위임받은 일부 권한을 이용하여 커스텀 코드와 상호작용하는 역할을 담당하고, 이를 통해 우리가 필요한 코드를 구현할 수 있도록 도와줌
- 회장은 UIApplication 객체이고, 비서실은 AppDelegate 객체라고 생각하면 됨. 
UIApplication 객체는 앱이 해야 할 아주 중요하고 핵심적인 일, 즉 앱의 생명 주기 관리나 이벤트 처리와 같은 것들을 담당하고, 앱 델리게이트는 커스텀 코드를 처리하는 비서의 성격을 띄는 것임
- AppDelegate 객체는 iOS 애플리케이션 내에서 오직 하나의 인스턴스만 생성되도록 시스템적으로 보장받음.  
→ AppDelegate 객체에 데이터를 저장하면 앱이 종료될 때까지 계속 데이터를 유지할 수 있음.
- UIApplication 객체와 AppDelegate 객체가 연관되어 앱이 실행되는 전체 과정
    - main() 함수가 실행된다.
    - main() 함수는 다시 UIApplicationMain() 함수를 호출한다.
    - UIApplicationMain() 함수는 앱의 본체에 해당하는 UIApplication 객체를 생성한다.
    - UIApplication 객체는 plist 파일을 바탕으로 앱에 필요한 데이터와 객체를 로드한다.
    - AppDelegate 객체를 생성하고 UIApplication 객체와 연결한다.
    - 이벤트 루프를 만드는 등 실행에 필요한 준비를 진행한다.
    - 실행 완료 직전, 앱 델리게이트의 application(_:didFinishLaunchingWithOptions:) 메소드를 호출한다.
- 반면, 스위프트는 C 기반의 언어가 아니라서 위의 1~5의 과정을 어노테이션 표기(@UIApplicationMain)로 대체함
- 스위프트에서는 앱 델리게이트 역할을 할 클래스에 @UIApplicationMain 어노테이션을 걸어 표시하는 방식으로 시스템에 델리게이트 클래스 정보를 전달함.  
iOS 시스템은 앱을 실행할 때 이 어노테이션이 표시된 클래스를 찾아 델리게이트로 지정함

![Untitled](CHAPTER%2002%20-%20iOS%20%E1%84%8B%E1%85%A2%E1%86%B8%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A9%E1%84%8F%E1%85%A9%E1%84%8B%E1%85%A1%20%E1%84%90%E1%85%A5%E1%84%8E%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%20fb6309255c9d47d390ffb39e4f8613e6/Untitled.png)

- 시스템에서 발생할 수 있는 여러 이벤트 중에서 우리가 원하는 이벤트를 제어하도록 핸들을 만들어 커스텀 코드와 연결해 놓으면 이벤트 루프에서는 특정 이벤트가 발생했을 때 우리가 만든 핸들을 통하여 커스텀 코드를 실행할 수 있도록 처리함
- 앱이 실행 목적을 모두 완료하고 더 이상 사용되지 않으면 시스템은 앱을 메모리에서 제거하기 위한 준비를 함.  
→ 앱 시스템은 델리게이트 클래스의 applicationWillTerminate(_:) 메소드를 호출함. 앱 종료 시에 처리해야 할 내용이 있다면 이 메소드 내부에 커스텀 코드로 작성해 두면 됨

## 2.1.2 MVC 패턴

- 모델(Model) – 뷰(View) – 컨트롤러(Controller)
- 모델(Model)은 데이터를 담당하고, 뷰(View)는 데이터에 대한 화면 표현을 담당하며, 컨트롤러(Controller)는 모델과 뷰 사이에 위치하여 데이터를 가공하여 뷰로 전달하고, 뷰에서 발생하는 이벤트를 입력받아 처리하는 역할을 담당함

## 2.1.3 앱의 상태 변화

- 앱의 상태 변화는 운영체제가 처리하는 영역
- iOS에서 앱이 가질 수 있는 상태값
    - Not Running : 앱이 시작되지 않았거나 실행되었지만 시스템에 의해 종료된 상태
    - Inactive : 앱이 전면에서 실행 중이지만, 아무런 이벤트를 받지 않고 있는 상태
    - Active : 앱이 전면에서 실행 중이며, 이벤트를 받고 있는 상태
    - Background : 앱이 백그라운드에 있지만 여전히 코드가 실행되고 있는 상태. 대부분의 앱은 Suspended 상태로 이행하는 도중에 일시적으로 이 상태에 진입하지만, 파일 다운로드나 업로드, 연산 처리 등 여분의 실행 시간이 필요한 앱일 경우 특정 시간 동안 이 상태로 남아 있게 되는 경우도 있음
    - Suspended : 앱이 메모리에 유지되지만 실행되는 코드가 없는 상태. 메모리가 부족한 상황이 오면 iOS 시스템은 포그라운드에 있는 앱의 여유 메모리 공간을 확보하기 위해 Suspended 상태에 있는 앱들을 특별한 알림 없이 정리함.
- iOS 앱은 Not Running 상태에서 시작하여 Inactive, Active를 거친 다음, Suspended 상태를 마지막으로 다시 Not Running 상태로 돌아감.  
→ 앱의 라이프 사이클(Life Cycle, 생명 주기)
- 하나의 상태에서 다른 상태로 옮겨가는 중일 때 이를 상태 변화라고 함
- 앱의 실행 상태가 변화할 때마다 앱 객체는 앱 델리게이트에 정의된 특정 메소드를 호출함. 이 메소드 내부에 적절한 커스텀 코드를 작성함으로써 우리가 원하는 작업이 실행되도록 할 수 있음
- 주요 메소드
    - Application(_:willFinishLaunchingWithOptions:)  
    앱이 구동되어 필요한 초기 실행 과정이 완료되기 직전에 호출되는 메소드
    - Application(_:didFinishLaunchingWithOptions:)  
    앱이 사용자에게 화면으로 표시되기 직전에 호출되는 메소드. 앱이 실행된 후에 진행할 커스터마이징이나 초기화를 위한 코드를 여기에 작성하면 됨
    - applicationDidBecomeActive(_:)  
    실행된 앱이 포그라운드, 즉 화면 전면에 표시될 때 호출되는 메소드. 앱이 Inactive 상태에 들어가면서 일시 중지된 작업이 있다면 이를 재시작하는 코드를 여기에 작성해 주어야 함
    - applicationDidEnterBackground(_:)  
    앱이 백그라운드 상태에 진입했을 때 호출됨. 이 메소드가 호출된다는 것은 미래의 어느 순간에 앱이 종료된다는 의미이므로, 잃어서는 안 되는 사용자 데이터를 종료 전에 미리 저장하거나, 공유 자원을 점유하고 있었다면 이를 해제해 주어야 함. 종료된 앱이 다시 실행될 때 현재의 상태를 복구할 수 있도록 필요한 상태 정보도 이 메소드에서 저장 처리하는 것이 좋음
    - applicationWillTerminate(_:)  
    앱이 종료되기 직전에 호출되는 메소드. 사용자 데이터 등을 종료 전에 한 번 더 저장해두는 것이 좋음
    - 이 외에 자세한 메소드 목록은 UIAppDelegateProtocol의 공식 문서 참고

# 2.2 iOS와 코코아 터치 프레임워크

## 2.2.1 iOS

- 네이티브 앱은 iOS 시스템 프레임워크를 기반으로 하고 스위프트 또는 오브젝티브-C 언어로 개발되며 iOS를 통해 직접 실행되는 앱을 말함. 비교되는 개념으로 웹 앱(Web App)이 있음
- 앱은 하드웨어와 직접 대화할 수 없으며, iOS에서 제공하는 시스템 인터페이스를 통해서만 하드웨어와 커뮤니케이션할 수 있음
- 하드웨어와 앱 사이를 중계해주는 iOS 인터페이스가 바로 코코아 터치 프레임워크

2.2.2 코코아 터치 프레임워크

- 코코아 터치 프레임워크는 애플 환경에서 터치 기반의 애플리케이션을 제작하기 위한 도구들의 모음이고 UIKit 프레임워크, 파운데이션 프레임워크를 포함함
- iOS 앱으로서의 특징적인 부분은 UIKit 프레임워크가, 내부적으로 돌아가는 기능은 파운데이션 프레임워크가 처리한다고 보면 됨
- OS X에서 실행되는 애플리케이션을 개발하기 위해 사용되던 프레임워크는 코코아 프레임워크
- 코코아 터치 프레임워크는 코코아 프레임워크를 기반으로 탄생
- 코코아 프레임워크는 앱킷(AppKit) 프레임워크와 파운데이션 프레임워크를 포함함
- 코코아 프레임워크나 코코아 터치 프레임워크를 구성하는 작은 단위의 프레임워크들은 계층 관계를 이뤄서 하위 계층부터 상위 게층까지 나열됨 
이 중에서 우리가 주로 프로그래밍에 사용하는 것은 상위 레벨의 프레임워크들임
- 상위 계층이란, 보다 사용자에 가깝고 구체적으로 구현되어 있어서 애플리케이션을 만들 때 가장 손쉽게 사용할 수 있는 형태를 말하고 이것을 구체화되어 있다라고 표현함
- 하위 게층에 속한 프레임워크는 추상적이면서 하드웨어 쪽에 더 가깝기 때문에 우리가 다루기에는 다소 번거로움
- 대부분의 경우 상위 프레임워크는 하위 프레임워크에 의존적임. 상위 프레임워크에 필요한 기능을 모두 직접 구현하는 것이 아니라, 하위 프레임워크를 통해 구현된 기능에 보다 구체적인 기능만 덧붙여 내놓는 식임
- iOS의 프레임워크 계층 구조
    - 코어 OS 계층  
    커널, 파일 시스템, 네트워크, 보안, 전원 관리, 디바이스 드라이버 등이 포함되어 있고 iOS가 운영체제로서 기능을 하기 위한 핵심적인 영역
    - 코어 서비스  
    계층 문자열 처리, 데이터 집합 관리, 네트워크, 주소록 관리, 환경 설정 등 핵심적인 서비스들을 제공함. 또한 GPS, 나침반, 가속도 센서나 자이로스코프 센서와 같이 디바이스의 하드웨어 특성에 기반한 서비스도 제공함. 이 계층에는 파운데이션 프레임워크, 코어 로케이션(Core Location), 코어 모션(Core Motion), 코어 애니메이션(Core Animation), 코어 데이터(Core Data) 프레임워크 등이 포함되어 있다.
    - 미디어 계층  
    여기에 속한 프레임워크들은 그보다 하위인 코어 서비스 게층에 의존적이며, 상위 게층인 코코아 터치 게층에 그래픽 관련 서비스나 멀티미디어 관련 서비스를 제공함. 코어 그래픽스, 코어 텍스트, 코어 오디오, 코어 애니메이션, AV파운데이션 등이 있다.
    - 코코아 터치 계층  
    이 계층은 애플리케이션 프레임워크 계층이라고도 불리며, 애플리케이션을 직접 지원하는 역할을 담당함. UIKit 프레임워크, Game Kit, Map Kit 등의 프레임워크가 여기에 속함.
- 예를 들어 디바이스에 장착된 카메라 모듈을 사용하기 위해서는 카메라 장치에 대한 디바이스 드라이버와 하드웨어에 대한 제어 정보를 모두 알아야 하지만, iOS에서는 이 같은 제어 처리를 코어 OS 계층이 모두 담당하는 까닭에 애플리케이션은 카메라 하드웨어에 대한 아무런 정보 없이도 카메라를 다룰 수 있음
- 대부분의 소프트웨어는 하드웨어와 직접 통신하지 않지만, 일부 분야에서는 하드웨어와 직접 통신하는 프로그램 코드를 작성하기도 함. 이를 임베디드 프로그래밍이라고 함. 임베디드 프로그래밍에서는 하드웨어와 직접 통신하고 제어하기 위해 부품의 명세서나 데이터 시트가 필요하고, 이를 이용하여 적합한 전기 신호를 만들어서 하드웨어를 제어하게 됨.
- 코코아 터치 프레임워크의 주요 프레임워크들은 자신들에게 속해있는 객체의 이름에 특정 접두어를 붙이는 경향이 있음.
    - Foundation Framework – NS
    - UIKit Framework – UI
    - UserNotifications Framework – UN
    - MapKit Framework – MK
    - Core Foundation – CF
    - Core Graphics – CG
    - AVFoundation – AV

# 2.3 앱을 구성하는 핵심 객체들

## 2.3.1 iOS 유저 인터페이스의 표현 구조

- 윈도우는 iOS에서 디바이스의 스크린을 빈틈없이 채우기 위한 객체로, 항상 유저 인터페이스 표현 계층의 최상위에 위치한다. 뷰의 일종이지만 직접 콘텐츠를 가지지는 않으며 콘텐츠를 가진 뷰를 내부에 배치하여 화면에 출력하는 역할을 함. 화면이 전환되더라도 윈도우 객체는 전환되지 않으며 단지 내부에 배치된 뷰의 콘텐츠만 변경됨
- 뷰는 콘텐츠를 담아 이를 스크린상에 표시하고, 사용자의 입력에 반응함. 윈도우의 일부를 자신의 영역으로 정의하고, 여기에 필요한 콘텐츠를 채워 넣어 스크린에 나타내는 동시에, 윈도우로부터 전달된 사용자의 입력에 반응하여 그에 맞는 결과를 처리함.
- 윈도우와 뷰 사이는 뷰 컨트롤러를 통해 연결됨. 뷰 컨트롤러는 뷰의 계층을 관리하여 윈도우에 전달하고, 모바일 디바이스에서 감지된 터치 이벤트를 윈도우로부터 전달받아 처리하는 역할을 함.
- 윈도우 객체는 항상 루트 뷰 컨트롤러만 참조함
- 스토리보드를 통해 편집하는 대부분의 뷰 컨트롤러들은 각자가 하나씩의 화면을 담당하여 콘텐츠를 표현하고 뷰를 관리함 → 씬(Scene)
- 씬을 담당하고 콘텐츠를 표시하는 뷰 컨트롤러를 콘텐츠 뷰 컨트롤러(Contents View Controller)라고 함
- 내부에 콘텐츠를 배치하는 대신 다른 뷰 컨트롤러를 배치하고, 이들을 서로 유기적인 관계로 엮이도록 만들어 줌. → 컨테이너 뷰 컨트롤러(Container View Controller)  
예) 네비게이션 컨트롤러, 탭 바 컨트롤러, 페이지 컨트롤러 등
- 뷰의 계층 구조(View hierarchy) 상에서 다른 뷰를 포함하는 뷰는 슈퍼 뷰(superview)가 되고, 슈퍼 뷰에 포함된 뷰는 서브 뷰(subview)가 됨
- 서브 뷰는 슈퍼 뷰를 기준으로 레이아웃을 구성하고, 슈퍼 뷰는 서브 뷰가 레이아웃을 구성할 수 있도록 내부적으로 원점을 포함하는 좌표 체계를 제공함
- 각각의 씬은 자신만의 뷰 게층 구조를 가지고 있으며, 뷰 계층 구조 최상위에는 하나의 뷰가 존재하는데 이 뷰를 루트 뷰(Root View) 또는 콘텐츠 뷰(Contents View)라고 함
- 루트 뷰 내부에는 각자의 크기와 영역, 표현할 콘텐츠를 가진 여러 개의 서브 뷰가 추가되는데, 일부 뷰의 영역은 서로 겹치기도 함. 루트 뷰는 이와 같은 서브 뷰들을 모아 하나의 전체 뷰를 구성하고, 뷰 컨트롤러를 통해 이를 윈도우에 전달함

## 2.3.2 뷰 컨트롤러

- 뷰 컨트롤러(View Controller)는 앱의 근간을 이루는 객체로, 모든 앱은 최소한 하나 이상의 뷰 컨트롤러로 구성된다.
- 우리는 항상 모든 객체를 루트 뷰 혹은 그 아래에 추가해야 함. 루트 뷰 없이 곧바로 뷰 컨트롤러에 객체를 추가할 수는 없음.
- 뷰 컨트롤러는 루트 뷰에 대한 참조를 가지며 루트 뷰 아래의 각 뷰는 자신의 하위에 있는 뷰를 참조함
- 뷰 컨트롤러가 하위의 모든 뷰에 대한 참조를 가지고 있지 않아도 모든 뷰에 접근할 수 있음

## 2.3.3 뷰 컨트롤러의 상태 변화와 생명 주기

- 뷰 컨트롤러는 생명 주기와 상태 변화를 가짐
- 앱을 처음 실행하거나 새로운 장면으로 전환할 때에는 그 장면을 담당하는 뷰 컨트롤러 객체가 새로 생성됨. 생성된 객체는 메모리에 로드되어 자신의 역할을 한다. 주어진 역할을 모두 끝내면 앱은 이전 장면으로 복귀하고, 생성되었던 뷰 컨트롤러 객체는 메모리에서 해제되면서 소멸함. 필요에 의해 그 장면으로 다시 전환할 경우, 뷰 컨트롤러 객체는 이미 소멸된 후이기 때문에 다시 새롭게 생성되고, 역할을 끝내고 나면 다시 소멸됨. 뷰 컨트롤러의 생명 주기는 이 같은 과정을 순환함.
- 화면 상태에 따라 메모리를 효율적으로 관리하기 위해서는 세부적인 제어가 필요함. → 튜닝

![Untitled](CHAPTER%2002%20-%20iOS%20%E1%84%8B%E1%85%A2%E1%86%B8%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A9%E1%84%8F%E1%85%A9%E1%84%8B%E1%85%A1%20%E1%84%90%E1%85%A5%E1%84%8E%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%20fb6309255c9d47d390ffb39e4f8613e6/Untitled%201.png)

- Appearing : 뷰 컨트롤러가 스크린에 등장하기 시작한 순간부터 등장을 완료하기 직전까지의 상태. 퇴장 중인 다른 뷰 컨트롤러와 교차하기도 하며, 이때 퇴장 중인 다른 뷰 컨트롤러의 상태는 Disappearing이 됨.
- Appeared : 뷰 컨트롤러가 스크린 전체에 완전히 등장한 상태를 나타냄
- Disappearing : 뷰 컨트롤러가 스크린에서 가려지기 시작해서 완전히 가려지기 직전까지의 상태, 또는 퇴장하기 시작해서 완전히 퇴장하기 직전까지의 상태. 이 상태의 뷰 컨트롤러는 새로 등장할 뷰 컨트롤러와 교차하기도 하며, 이때 등장 중인 다른 뷰 컨트롤러의 상태는 Appearing임.
- Disappeared : 뷰 컨트롤러가 스크린에서 완전히 가려졌거나 혹은 퇴장한 상태.
- 화면이 처음 실행되거나 또는 퇴장한 상태에서 다시 등장하기 시작하는 상태(=Appearing)로 바뀌는 동안 뷰 컨트롤러는 앱 객체에 의해 viewWillAppear(_:) 메소드가 호출됨. 화면이 등장할 때마다 데이터를 갱신해 주고 싶다면, 이 메소드를 오버라이드하여 원하는 코드를 작성하면 됨.
- 화면이 등장하기 시작한 단계를 넘어서 완전히 등장하고 나면 viewDidAppear(_:) 메소드가 호출됨.
- 스크린에서 화면이 퇴장하는 상태 변화가 발생하면 그 즉시 viewWillDisappear(_:) 메소드가 호출되고, 상태 변화가 완료되었을 때 viewDidDisappear(_:) 메소드가 호출됨
- 생명 주기는 ‘언제’의 문제를 ‘어디’의 문제로 바꾸어 주는 역할을 함.
- 앱은 시스템 프레임워크와 커스텀 코드 사이에서 상호 작용하는 애플리케이션이기 때문에, 둘 모두를 잘 파악하는 것이 중요
