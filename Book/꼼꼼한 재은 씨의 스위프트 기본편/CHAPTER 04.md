# CHAPTER 04 – 화면 전환

# 4.1 iOS에서의 화면 전환 개념

- 기존 화면과 새로운 화면 사이에는 서로 참조 관계가 성립함. 화면이 전환되는 방식에 따라 이들은 서로 직접 참조할 수 있거나, 또는 화면 전환을 관리하는 전담 객체를 통해 간접적으로 참조하기도 함.

# 4.2 화면 전환 기법1 : 뷰를 이용한 화면 전환

- iOS에서는 하나의 뷰 컨트롤러 아래에 하나의 루트 뷰를 관리하는 MVC 패턴을 기본으로 함

# 4.3 화면 전환 기법2 : 뷰 컨트롤러 직접 호출에 의한 화면 전환

- 현재의 뷰 컨트롤러에서 이동할 대상 뷰 컨트롤러를 직접 호출해서 화면을 표시하는 방식 → 직접 표시한다는 의미에서 프레젠테이션 방식이라고 부르기도 함
- present(_:animated:) 메소드를 사용하면 화면을 전환할 수 있음
- 프레젠트 메소드의 구조  
present(<새로운 뷰컨트롤러 인스턴스>, animated:<애니메이션 여부>)
    - 첫 번째 인자값은 새로운 화면을 담당하는 뷰 컨트롤러의 인스턴스
    - 필요에 따라 애니메이션 효과를 줄 수 있는데 두 번째 인자값에 true를 입력하면 화면 전환 시 애니메이션 효과가 적용됨
- 화면 전환이 완료되는 시점에 맞추어 특정 로직을 실행해줘야 하면  
present(_:animated:completion:) 메소드를 사용함
    - 세 번째 매개변수는 실행 구문을 클로저나 함수 형식으로 입력받아, 화면 전환이 완전히 끝난 후에 호출해 주는 역할을 함
    - 프레젠트 메소드 다음 줄에 작성된 코드 구문은 화면 전환이 완전히 끝난 다음에 실행된다는 보장을 할 수 없음.
- 하나의 처리가 끝나기를 기다리지 않고 바로 다음 작업을 이어서 수행하는 방식을 비동기 방식이라고 부름. 화면 전환은 비동기 방식으로 동작하기 때문에, 화면 전환이 완전히 끝난 후에 실행해야 할 구문이 있다면 클로저나 함수 형식으로 작성하여 프레젠트 메소드의 세 번째 인자값에 넣은 다음, 시스템이 알맞게 호출해 주기를 기다려야 함
- 프레젠트 메소드를 이용한 화면 전환은 기존의 뷰 컨트롤러(이하 VC1)를 그대로 둔 채, 그 위에 새로운 뷰 컨트롤러(이하 VC2)의 화면을 덮는 방식임
- 기존 뷰 컨트롤러인 VC1에서는 presentedViewController 속성에다 자신이 표시하고 있는 새로운 뷰 컨트롤러의 포인터를 저장하고, 새로운 뷰 컨트롤러인 VC2에는 presentingViewController 속성에다 자신을 표시한 뷰 컨트롤러의 포인터를 저장함.
- 화면을 전환할 때 프레젠트 메소드를 이용했다면, 이전 화면으로 복귀할 때는 dismiss(animated:) 메소드를 사용함
    - 이전 화면으로 돌아가는 기능이기 때문에 뷰 컨트롤러의 인스턴스를 인자값으로 받지는 않음
    - 화면 복귀 시 애니메이션을 적용할지 말지를 결정하는 값만 전달해주면 됨
- dismiss(animated:completion:) 메소드도 마찬가지로 클로저 또는 함수 형식을 입력받음
- 개념적으로는 기존 화면이 새로운 화면 위로 올라오는 것이 아니라 기존 화면을 덮고 있던 새 화면을 걷어내는 것임. 걷어낸 화면의 뷰 컨트롤러 객체는 운영체제에 의해 곧 메모리에서 해제됨

## 4.3.1 화면 전환 실습

- 객체지향 언어에서 메모리에 올려진다는 것은 클래스의 인스턴스가 생성된다는 것을 의미함.
- 외형을 담당하는 스토리보드의 화면 구조와 기능을 담당하는 뷰 컨트롤러 클래스를 합쳐서 하나의 인스턴스가 만들어져야 정상적으로 화면에 표시될 수 있는 것은 물론, 제대로 동작할 수도 있음
- UIViewController 클래스에 정의된 속성 modalTransitionStyle은 어떤 스타일을 적용해서 전환할 것인지를 결정함

## 4.3.2 뒤로 가기 버튼 만들기

- iOS 앱에서 이전 화면으로 돌아가는 것을 Unwind 라고 부름
- 프레젠테이션 방식으로 화면을 전환할 경우, 뷰 컨트롤러의 포인터는 차례로 프레젠테이션 체인(Presentation Chain)에 저장됨
- 이전 화면으로 되돌아가는 과정은 이 프레젠테이션 체인에 저장된 뷰 컨트롤러의 포인터를 제거하는 방식으로 이루어짐.
- 프레젠테이션 체인에서 포인터가 제거된 뷰 컨트롤러들은 ARC 시스템에 의해 메모리에서 차례로 해제됨
- 잊지 말아야 할 것은 화면 전환 방식이 달라지면 그것에 맞는 Unwind 메소드도 달라짐.

# 4.4 내비게이션 컨트롤러를 이용한 화면 전환

- 앱의 내비게이션을 표시해줄 수 있는 내비게이션 바(Navigation Bar)가 내장됨
- 내비게이션 컨트롤러는 뷰 컨트롤러의 전환을 직접 컨트롤하고, 앱의 내비게이션 정보를 표시하는 역할을 할 뿐만 아니라 화면 전환이 발생하는 뷰 컨트롤러들의 포인터를 스택(Stack)으로 관리하여 원하는 화면에 접근하기 쉽게 한다.
- 이 컨트롤러가 제어하는 모든 뷰 컨트롤러에 내비게이션 바를 생성하는 특징을 가짐
- 내비게이션 컨트롤러는 항상 콘텐츠 계층 구조의 시작점 역할을 하는 뷰 컨트롤러와 함께 다니는데, 이를 루트 뷰 컨트롤러(Root View Controller)라고 함
- 내비게이션 컨트롤러는 화면에 현재 표시되고 있는 뷰 컨트롤러들을 내비게이션 스택(Navigation Stack)을 이용하여 관리함.
- 화면을 전환할 때, 새로운 화면을 표시하려면 pushViewController(_:animated:) 메소드를, 이전 화면으로 돌아오려면 popViewController(animated:) 메소드를 호출하면 됨
- 특별한 목적이 없다면 내비게이션 바의 왼쪽 영역은 항상 비워두는 것이 좋음
- navigationController?.pushViewController(uvc, animated:true)
    - pushViewController(_:animated:) 메소드는 기술적 관점에서 내비게이션 스택 최상위에 뷰 컨트롤러 객체 uvc를 추가하는 것이지만, 사용자들에게는 화면을 전환하는 결과로 나타남
    - present(_:animated:) 메소드가 뷰 컨트롤러 자신을 대상으로 호출하는 것이었던 반면, pushViewController(_:) 메소드는 호출하는 대상이 내비게이션 컨트롤러임. self.navigationController는 현재의 뷰 컨트롤러에 연결된 내비게이션 컨트롤러를 가리킴
- 내비게이션 컨트롤러는 직접 연결된 루트 뷰 컨트롤러뿐만 아니라 내비게이션 컨트롤러가 제어하는 모든 뷰 컨트롤러 상단에 내비게이션 바를 삽입하여 자신의 존재를 알림
- 내비게이션 컨트롤러는 각 뷰 컨트롤러마다 내장된 내비게이션 바에 이전 화면으로 되돌아갈 수 있는 버튼을 자동으로 만들어 줌
- 자동으로 생성된 뒤로 가기 버튼의 타이틀은 이전 화면의 내비게이션 바에 작성된 타이틀과 같음
- 동일한 뷰 컨트롤러임에도 화면 전환 방식에 따라 상태가 달라져서 내비게이션 컨트롤러의 제어하에 놓이기도 하고 그렇지 않기도 함. 내비게이션 컨트롤러의 제어하에 놓인 뷰 컨트롤러는 자동으로 내비게이션 바가 추가되고, 그렇지 않은 뷰 컨트롤러는 내비게이션 바가 추가되지 않음
- _ = self.navigationController?.popViewController(animated: true)
    - 스위프트에서 언더바는 대부분 “값을 대입할 변수가 필요한 것은 알고 있지만, 나는 그 값이 필요하지 않으니 굳이 변수에 값을 할당하지 말아 주세요” 이런 의미임.
    - 위 코드에서는 언더바를 사용해서 익명 변수 처리를 함
    - 이렇게 처리할 경우 반환값이 필요하지 않다는 것을 명시적으로 표현

# 4.5 세그웨이를 이용한 화면 전환

## 4.5.5 전처리 메소드의 활용

- 전처리 메소드(Pre-Process Method)
    - 우리가 구현해 놓으면 시스템이 필요한 시점에 호출하는 방식
    - 우리가 호출하고 싶을 때 임의로 호출하지 못 함
    - 패시브 스킬
    - 필요할 때 직접 격발하는 총이 아니라 미리 땅에 묻어서 설치해두면 적절한 상황에 알아서 터지는 지뢰
- NSLog는 파운데이션 프레임워크에서 정의된 클래스로, 입력된 문자열을 Xcode의 디버그 콘솔에 출력하는 기능을 함
- 프로그래밍 과정에서 직접적인 처리 내용과는 관련이 없지만 프로세스의 흐름을 살펴보기 쉽도록 출력하는 메시지를 로그(Log)라고 부름
