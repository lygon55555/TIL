# CHAPTER 07 – 데이터 저장(3) – 코어 데이터 : 코코아 전용의 데이터 프레임워크

- 코어 데이터는 애플이 코코아 개발 환경을 통해 제공하는 인메모리(In-Memory) 방식의 데이터 관리 프레임워크이다.
- 코어 데이터를 통해 읽고 쓰는 모든 데이터는 원칙적으로 메모리에 로드된 다음에 처리됨. 대부분의 작업이 영구 저장소에서 직접 처리되고, 효율성을 위해 읽기 목적의 데이터 일부만 메모리에 올려 놓고 사용하는 데이터베이스와는 구분됨
- 코어 데이터는 영구 저장소로 SQLite 대신 바이너리 파일을 사용할 수 있을 뿐만 아니라 영구 저장소를 아예 사용하지 않고 순수하게 인메모리 방식으로만 사용하는 것도 가능
- 코어 데이터에서도 뷰 컨트롤러는 단지 관리 객체 컨텍스트(Managed Object Context) 객체를 통해 필요한 메소드만 호출하면 됨
- 코어 데이터에서는 각각의 레코드를 관리 객체(Managed Object)라고 하는데, 이 관리 객체는 VO 패턴과 유사한 형태로 정의된 클래스 인스턴스에 할당된 상태로 사용됨. 이를 코어 데이터에서는 MO 패턴이라고 함. 또한 코어 데이터는 이 구조를 더욱 강화하여 MO 클래스의 프로퍼티를 엔티티의 각 어트리뷰트와 직접 연결시키는 방식을 사용하는데, 데이터베이스 관리 프레임워크에서 자주 사용되는 이 방식을 프로그래밍 이론에서는 ORM 매핑이라고 함

# 7.1 코어 데이터 이해하기

## 7.1.1 객체 그래프 관리자(Object Graph Manager)

- 코어 데이터는 ‘애플리케이션에서 모델(Model) 계층의 객체를 관리하는 데 사용하는 프레임워크이자 라이프 사이클이나 영속성 관리를 위한 기능을 제공하는 객체 그래프 관리자(Object Graph Manager)’
- 수학적으로 그래프란 노드(Node)와 링크(Link)로 표현되는 도형을 가리킴
- 객체 지향 프로그래밍에서 객체란, 독립적이고 자체적인 생명 주기를 가지면서 속성과 기능으로 이루어진 단위 구성체를 의미함. 코어 데이터는 영구 저장소에 저장된 각각의 레코드를 읽어들인 다음, 이와 같은 독립적인 객체 형태로 만들어냄. 우리가 데이터를 다루는 행위는 코어 데이터에서 모두 객체 단위로 이루어짐. 이때 레코드의 데이터가 객체화된 것을 가리켜 ‘관리되는 객체(Managed Object)’, 또는 ‘관리 객체’라고 부름
- 코어 데이터에서 정규화된 데이터 객체는 다른 객체와 참조 관계 하에 있으며, 서로 간의 관계를 통해 데이터의 완전성을 보장받을 수 있음. 이때 객체를 하나의 노드로 간주하고, 서로 간의 연관 관계를 링크로 이어보면 다양하게 연결되는 복합적인 그래프 형태의 도형을 얻게 되는데, 이것이 바로 객체 그래프이다.
- 코어 데이터가 객체 그래프의 관리를 담당한다는 것은, 객체 A를 객체 B와 연결할 수 있으며 이 연결을 통해 A와 B는 영속적으로 동기화된다는 것을 뜻함. 객체 A에서 업데이트가 발생하면 이에 연결된 객체 B에서도 연관된 데이터의 업데이트가 수행됨. 또한 한쪽에서 객체를 삭제하면 연결을 타고 연이어 객체 B에서도 관련된 데이터가 삭제되기도 함. 좋은 점은, 이 같은 작업을 코어 데이터가 알아서 해 주기 때문에 우리가 딱히 신경 쓸 부분이 없음
- 코어 데이터는 전체적으로 데이터베이스와 비슷한 기능을 제공하지만, 엄밀하게 말해 데이터 저장에 관련된 기능을 제공하는 프레임워크이다. 또한 데이터를 객체로 다루며, 정규화된 데이터 사이의 참조 관계를 바탕으로 한쪽 객체에서 발생한 변경 내용을 다른 쪽 객체에도 전파하는 등 객체 간 관계의 일관성을 유지하는 객체 그래프 관리자로서의 특징을 가짐. 이런 특성들 때문에 우리는 코어 데이터를 마치 데이터베이스인 양 사용해도 거의 문제가 되지 않으며, 데이터베이스에서처럼 조인 구문을 사용하지 않고도 정규화된 데이터를 참조할 수 있음.

## 7.1.2 코어 데이터의 구조

- 코어 데이터는 다층 구조로 이루어진 프레임워크.
- 관리 객체(Managed Object)는 코어 데이터에서 데이터를 저장하기 위해 생성하는 인스턴스이다. 관계형 데이터베이스에서 테이블의 행이나 레코드 정도로 생각하면 됨. 코어 데이터는 모든 레코드를 객체화하여 다루기 때문에, 테이블의 행 하나하나에 해당하는 레코드가 코어 데이터에서는 독립된 객체로 동작함. 이때, 레코드를 구성하는 각 칼럼들은 관리 객체의 속성이 됨.
- 사원 정보 레코드 두 개를 읽기 위해서는 두 개의 관리 객체가 필요하며, 새로운 레코드를 추가할 때 역시 데이터를 담을 관리 객체가 생성되어야 함. 코어 데이터에서 사용하는 관리 객체는 모두 NSMangedObject 클래스나 또는 그 하위 클래스의 인스턴스이며, 생성된 관리 객체들은 모두 관리 객체 컨텍스트에 담겨 관리됨
- 관리 객체 컨텍스트(Managed Object Context, 이하 컨텍스트)는 코어 데이터에서 가장 핵심적인 객체로, 크게 두 가지 역할을 담당함. 첫 번째 역할은 관리 객제를 담거나 생성, 삭제할 수 있는 만능 상자. 코어 데이터가 다루는 모든 데이터는 메모리에 로드된 상태로 처리된다고 설명했는데, 이때의 메모리는 곧 컨텍스트를 의미함. 데이터를 메모리에 로드한다는 것 또한 컨텍스트에 데이터를 담는 것을 의미.
- 컨텍스트의 두 번째 역할은 영구 저장소 및 영구 저장소 코디네이터에 대한 관리자이다. 컨텍스트 객체의 특정 메소드를 호출하는 것만으로 데이터를 읽거나 쓰는 데에 필요한 모든 작업을 처리할 수 있음.
- DAO 패턴을 다룰 때 우리는 실질적인 SQLite 처리를 모두 DAO 클래스 내부로 밀어 넣어 구현하고, 뷰 컨트롤러에서는 단순히 DAO 객체의 메소드만 호출했었는데 컨텍스트 역시 이와 마찬가지 역할을 함
- 영구 저장소 코디네이터(Persistent Store Coordinator, 이하 코디네이터)는 컨텍스트와 직접 데이터를 주고 받으면서 다양한 영구 저장소들의 접근을 조정하고, 해당 저장소에 대한 실제 입출력을 담당함
- 관리 객체 모델(Managed Object Model)은 데이터베이스로 치자면 테이블의 구조를 정의하는 스키마에 해당하는 것으로, 코어 데이터에서 테이블에 대응되는 엔티티(Entity)의 구조를 정의하는 객체인 동시에 이 스키마를 바탕으로 정의된 MO 패턴의 모델 클래스를 가리킴
- 관리 객체 모델은 클래스이자 형식이고 구조인 반면, 관리 객체는 이를 바탕으로 생성된 인스턴스이다.
- 영구 객체 저장소(Persistent Object Store)는 코어 데이터를 사용할 때 데이터가 저장되는 저장소 환경을 의미함
    - 인메모리 저장소 타입(NSInmemoryStoreType) : 메모리 기반의 저장소를 사용하는 방식. 주로 데이터 객체의 런타임 캐싱에 활용됨
    - 플랫 바이너리 저장소 타입(NSBinaryStoreType) : 데이터를 단순 바이너리 파일 형식으로 저장하는 방식. 데이터 조회 성능이 빠르지만 저장된 데이터의 크기가 커질수록 바이너리 파일의 크기가 커지고 초기 로딩 시간도 늘어난다는 단점이 있음
    - XML 저장소 타입(NSXMLStoreType) : XML 방식으로 데이터를 변환하여 저장하는 방식. 파일에 저장하는 것이기 때문에, 부분적으로 저장되지 않고 항상 전체가 저장되거나 저장되지 않는 원자성을 띰
    - SQLite 데이터베이스(NSSQLiteStoreType) : iOS 프로젝트에서 코어 데이터가 기본으로 채택하는 방식
- SQLite 저장소 타입이 iOS에서 기본 타입으로 사용된다. 하지만 부분적인 업데이트를 수행하는 저장 방식 때문에 대표적인 문제가 처리 속도와 원자성임.
- 외부 경로의 저장소 파일을 사용할 때에는 저장 데이터의 변조가 가능하다는 것을 인식하고, 암호화 등의 기술을 적용하는 것이 좋음

## 7.1.3 인메모리(In-Memory) DB

- 코어 데이터는 인모메리 방식으로 동작하는 프레임워크
- 변경 내역을 영구 저장소에 반영하는 과정을 가리켜 보통 커밋(Commit) 또는 동기화(Synchronize)라고 부르는데, 커밋이 발생하기 전까지 변경된 데이터는 메모리에서만 존재함
- 영구 저장소와 메모리에 저장된 레코드 사이에 일어나는 데이터 교환 방식은 미러링(Mirroring)과 유사함. 영구 저장소에서 레코드를 로딩할 때에는 저장된 레코드를 그대로 읽어 관리 객체로 만들어 내고, 반대로 관리 객체를 영구 저장소에 저장할 때에는 메모리 상에서 수정된 객체가 그대로 영구 저장소에 반영되는 식.
- 영구 저장소로 SQLite를 선택한 상태에서 컨텍스트의 관리 객체를 저장소에 커밋할 때에는 차등저장(Differential Save) 메커니즘이 사용됨. 이것은 매번 데이터 전체를 커밋하는 대신 마지막 저장 이후에 변경된 부분만 커밋하는 방식으로, 빠르고 가볍게 처리할 수 있다는 장점이 있음
- 코어 데이터를 사용하면서 생성, 수정 또는 삭제된 데이터에 대해 최종적으로 save() 메소드를 호출하면 메모리상의 관리 객체 변경 내용이 그대로 영구저장소에 커밋됨
- 하지만 매 작업 단위마다 커밋을 하게 되면 코어 데이터와 영구 저장소 사이에 추가적인 오버헤드가 발생할 수 있어서 성능에 좋지 않은 영향을 끼칠 수 있음
- 풀 백업(Full Backup)은 전체 데이터베이스의 데이터를 모두 빠짐없이 백업해 두는 것
- 차등 백업(Differential Backup)은 마지막 풀 백업 시점 이후의 변경 사항 전체를 백업하는 방식
- 증분 백업(Incremental Backup)은 마지막에 수행된 증분 백업 이후의 변경 사항만 백업하는 방식

## 7.1.4 코어 데이터의 한계

- 코어 데이터에서 많은 수의 객체들을 수정하거나 삭제해야 할 경우에는 NSFetchRequest 객체에 정의된 returnDistinctResults, propertiesToFetch 등의 속성을 적극 활용하여 객체의 전체 프로퍼티를 모두 불러오는 것을 지양하고, 주기적으로 NSManagedObjectContext#refresh(_:mergeChanges:) 메소드를 호출하여 변경 내역이 없는 객체들을 해제하며, 컨텍스트를 영구 저장소에 커밋한 후에는 로딩된 모든 객체를 메모리에서 해제해 주는 등의 방법을 사용하여 메모리를 효율적으로 관리해 주어야 함
- 코어 데이터는 “Unique” 키에 해당하는 기능이 제공되지 않기 때문에 중복 값의 입력을 방지하려면 애플리케이션에서 비즈니스 로직을 통해 처리해 주어야 함
- 코어 데이터는 자신의 영역을 벗어나는 데이터 로직에 대해서는 관여할 수 없기 때문에, 이를 비즈니스 로직으로 처리해야 함
- 코어 데이터는 원칙적으로 싱글 쓰레드만 지원함 → 한 번에 하나의 작업만 처리할 수 있음
- 멀티 쓰레드 환경이라면 기존의 쓰레드가 데이터 저장을 끝내고 난 후에 다른 쓰레드가 새로운 컨텍스트 객체를 이용해서 데이터를 읽어들이는 방식으로 코드를 작성해야 함

# 7.2 코어 데이터 관리 객체 모델링

- 코어 데이터에서 스키마는 곧 관리 객체 모델을 의미하는데, NSManagedObjectModel 클래스의 인스턴스임. 관리 객체 모델을 사용하면 영구 저장소의 레코드를 애플리케이션에서 사용하는 관리 객체에 연결할 수 있음

## 7.2.1 엔터티

- 엔터티(Entity)는 데이터가 저장될 구조 또는 형식으로, 관계형 데이터베이스에서 테이블에 해당하는 개념으로 이해하면 됨. 내부 구성은 크게 어트리뷰트(Attribute)와 릴레이션(Relation), 그리고 페치 속성(Fetched Properties)으로 이루어지는데, 어트리뷰트는 엔터티의 하위 속성들을 정의하는 역할을 하고, 릴레이션은 다른 엔터티와의 관계를 정의하는 역할을 함. 마지막으로 페치 속성은 데이터 검색 시 반복 사용되는 요청이나 값만 바꾸어 사용하는 비슷한 요청들을 미리 템플릿 형태로 만들어 놓는 것을 말함
- 엔터티의 내용을 클래스의 형태로 생성하면 NSManagedObject 혹은 그의 서브 클래스가 되지만, 엔터티 자체는 NSEntityDescription 클래스로 표현됨. NSEntityDescription은 추상 클래스로서 엔터티의 구조를 설명한다는 의미를 가짐. 이때의 설명은 엔터티의 각 어트리뷰트와 릴레이션을 가리킴. 새로운 데이터의 추가가 필요할 때 NSEntityDescription을 이용하여 인스턴스를 생성하면 그 결과로 NSManagedObject 객체 혹은 그의 서브 클래스 객체가 만들어지며, 이를 컨텍스트가 인식하여 관리하게 됨

## 7.2.2 엔터티 정의하기

- .xcdatamodeld 확장자를 가지는 코어 데이터 모델 파일

## 7.2.3 엔터티 설정 추가하기

- 데이터 모델 클래스의 이름이 엔터티명과 완전히 동일할 필요는 없으나, 접미사 MO를 엔터티명 뒤에 붙여서 데이터 모델 클래스명을 정의해 주는 것이 관례. MO는 Model Object의 약자
- 코어 데이터의 엔터티는 상속 가능
- 상속 관계를 설정할 때에는 인스펙터의 Parent Entity 항목을 이용함

## 7.2.4 어트리뷰트 정의하기

- 엔터티는 어트리뷰트와 릴레이션으로 정의됨. 어트리뷰트는 엔터티 내부를 구성하는 요소이며, 릴레이션은 다른 엔터티와의 관계를 정의하는 요소에 해당함
- 어트리뷰트는 데이터베이스에서의 칼럼, 또는 필드와 유사한 개념으로 사용됨. 어트리뷰트의 이름은 대소문자를 구분하지만 대문자로 시작할 수는 없고 언더바는 자제하는 것이 좋음
- 어트리뷰트에는 타입 설정에 따른 세부 도메인(가질 수 있는 값의 범위)을 설정할 수 있음
- 옵셔널 타입의 nil 값과 구분할 수 있도록 기본 값 정도는 지정해 주는 것이 좋음

## 7.2.5 릴레이션 정의하기

- 코어 데이터에서 릴레이션은 정규화된 데이터 모델의 연결이나 참조를 위해 사용됨. 엔터티에 추가된 릴레이션은 어트리뷰트처럼 동작한다는 점에서 관계형 데이터베이스의 외래 키 칼럼과 같은 역할을 함
- 릴레이션은 다른 쪽 엔터티를 직접 참조함으로 해당 데이터를 몽땅 반입하는 방식
- 단방향 릴레이션을 설정할 때에는 이것이 일대일 관계인지 일대다 관계인지에 대해 결정해 주어야 함. 특정 릴레이션이 일대일 관계일 때에는 Type 속성을 “To One”으로, 일대다 관계일 때에는 “To Many”로 설정하면 됨
- 데이터베이스의 외래 키는 양쪽 테이블이 사이좋게 공통 칼럼을 공유하는 방식이기 때문에 방향성이 존재하지 않지만, 코어 데이터의 릴레이션은 한쪽 엔터티가 다른 쪽 엔터티를 참조하는지 여부만 판단하기 때문에, 방향성을 가지게 됨. 이때 엔터티 A가 B를 참조하는 것을 일반참조라고 하고, 반대로 엔터티 B가 A를 참조하는 것을 역참조라고 함
- Inverse 항목은 두 개의 엔터티가 상호 참조하는 경우 순환 참조의 오류를 방지하기 위해 사용됨. Inverse 항목을 통해 상대방 릴레이션과 서로 역참조 관계라는 것을 알려줌으로써 순환 참조를 차단할 수 있음
- Delete Rule은 참조 대상 엔터티의 레코드가 삭제되었을 경우 이를 참조하고 있는 엔터티의 레코드를 어떻게 할 것인지를 결정하는 것으로, 이 옵션이 설정된 릴레이션은 대상 엔터티의 레코드가 삭제될 시 이를 참조하고 있는 레코드를 해당 옵션에 설정된 내용에 따라 처리함. 선택 가능한 옵션 항목은 3개
    - Nullify : 참조 대상이 삭제되면 nil 값으로 처리
    - Cascade : 참조 대상이 삭제되면 이를 참조하고 있던 모든 레코드를 함께 삭제
    - Deny : 참조하고 있는 레코드가 있을 경우 참조 대상을 삭제하지 못 하도록 막는 옵션

## 7.2.6 엔터티와 데이터 모델 클래스

- 엔터티가 정의되면 코어 데이터는 자동으로 엔터티 구조를 객체 형태로 변환한 데이터 모델 클래스(이하 모델 클래스)를 생성함. iOS에서는 엔터티명 뒤에 MO를 붙이는 것을 권장함
- 모델 클래스 위에 붙은 @objc 어트리뷰트는 이 클래스를 오브젝티브-C 기반의 코드에서도 인식할 수 있음을 나타냄. 프로퍼티 앞에 붙은 @NSManaged 어트리뷰트는 이 프로퍼티가 동적으로 정의될 수 있음을 컴파일러에게 알려주는 역항을 함. 이 특성 덕분에, @NSManaged 어트리뷰트가 붙은 저장 프로퍼티는 익스텐션에서도 정의할 수 있음. 이는 일반적으로 익스텐션에서 저장 프로퍼티를 정의할 수 없다는 규칙에 대한 예외 사항이므로 주의해야 함
- 배열이 아닌 집합 타입인 NSSet 타입을 사용하는 것은 동일 레코드를 중복 참조하는 것을 방지함. NSSet 타입은 저장된 값들의 순서를 보장하지 않기 때문에, 참조 순서가 중요한 데이터라면 다음과 같이 Ordered 속성을 활성화해 주어야 함. 이 속성이 활성화되면 모델 클래스의 해당 프로퍼티 타입은 NSOrderedSet으로 정의됨
- 코어 데이터에서 사용되는 모든 모델 클래스는 NSManagedObject의 하위 클래스여야 하므로, 커스터마이징 하는 경우에도 NSManagedObject를 서브 클래싱해야 함
- 코어 데이터가 자동으로 생성한 모델 클래스는 탐색기 영역에서 아예 표시되지 않음.
- 커스텀 모델 클래스를 명시적으로 생성하고자 한다면 Codegen 속성을 반드시 Manual/None으로 변경해 주어야 함
- 코어 데이터가 자동으로 생성하는 모델 클래스와 [Create NSManagedobject Subclass…]를 이용하여 생성되는 커스텀 모델 클래스는 서로 다른 별개의 객체이다.
- 모델 클래스를 생성하는 방식은 모두 세 가지
    - (1) NSManagedObject를 서브 클래싱하여 직접 정의한다 (Codegen 속성은 Manual/None으로 둔다.)
    - (2) [Create NSManagedobject Subclass…]를 이용하여 생성한다. (Codegen 속성은 Manual/None으로 둔다.)
    - Codegen 속성을 Class Definition으로 둔 채 아무것도 하지 않는다(코어 데이터가 자동으로 생성한다.)
- MO 스타일로 정의된 모델 클래스를 굳이 사용하고 싶지 않다면 상위 클래스인 NSManagedObject를 그대로 사용해도 무방함. NSManagedObject는 기본적으로 키-밸류 구조의 데이터 형식을 가지므로, 어트리뷰트의 값을 읽어올 때에는 value(_:forKey:) 메소드를 이용하면 됨

# 7.3 코어 데이터 실습

## 7.3.1 프로젝트 생성

- 코어 데이터에서 엔터티 설계를 담당하는 파일은 *.xcdatamodeld라는 확장자를 가짐
- let container = NSPersistentContainer(name: “Chapter07_CoreData”)  
이 구문은 프로젝트에 추가된 xcdatamodeld 파일을 코어 데이터 시스템에 등록하고, 이를 이용하여 NSPersistentContainer 객체를 생성하는 역할을 함.
- let context = persistentContainer.viewContext .viewContext  
속성을 통해 반환되는 값은 NSManagedObjectContext 객체이고 관리 객체 컨텍스트에 해당함. 코어 데이터에서 데이터를 읽고 쓰기 위해서는 매번 컨텍스트 객체가 필요함. 앱 델리게이트 객체 → persistentContainer → vieContext 순으로 참조해야 함

## 7.3.3 목록 구현하기

- 코어 데이터에서 레코드를 읽어오는 과정을 보통은 페치(fetch)라는 단어로 표현
    - 1단계 앱 델리게이트 객체 참조
    - 2단계 컨텍스트 참조
    - 3단계 요청 객체(NSFetchRequest) 생성
    - 4단계 fetch(_:) 메소드 호출하여 레코드 가져오기
- 코어 데이터에 저장된 데이터를 가져올 때에는 요청 사항을 정의한 NSFetchRequest 객체가 사용됨. 이 객체에는 다양한 요청들을 복합적으로 정의할 수 있음.
    - (1) 어디에서 데이터를 가져올 것인가? (엔터티 지정)
    - (2) 어떤 데이터를 가져올 것인가? (검색 조건 지정)
    - (3) 어떻게 데이터를 가져올 것인가? (정렬 조건 지정)
- 1번 요청은 SELECT 구문에서 FROM에 해당하는 내용이고, 2번 요청은 WHERE 조건절에, 그리고 3번 요청은 ORDER BY에 해당하는 내용
- NSFetchRequest 객체를 생성할 때 특정 엔터티의 이름을 인자값으로 넣어줌으로써 어느 엔터티에서 데이터를 가져올지 선택할 수 있음

## 7.3.4 등록 기능 구현하기

- 코어 데이터에 데이터를 등록하는 로직은 크게 세 단계
    - 1단계 빈 관리 객체를 생성하고, 이를 컨텍스트 객체에 등록함
    - 2단계 생성된 관리 객체에 값을 채워 넣음
    - 3단계 컨텍스트 객체의 변경 사항을 영구 저장소에 반영함. 이를 커밋 또는 동기화라고 부름
- 다음과 같은 방식으로 관리 객체를 생성하여 컨텍스트 객체가 관리할 수 있도록 해 주어야 함  
let entity = NSEntityDescription.entity(forEntityName: “Board”, in: context)  
let object = NSManagedObject(entity: entity, insertInto: context)
- 두 줄로 이루어진 위 구문은 다음의 한 줄의 구문으로 대신할 수 있음  
let object = NSEntityDescription.inserNewObject(forEntityName: “Board”, into: context)
- 이렇게 생성된 관리 객체에 setValue(_:forKey:) 메소드를 이용하여 값을 설정하고 나면 일단 관리 객체에 대한 작업은 완료. 현재까지는 메모리에만 반영된 상태이다. 데이터를 생성/수정/삭제하는 과정에서는 항상 제일 마지막에 save() 메소드 호출을 통해 컨텍스트의 변경 사항을 영구 저장소에 반영해 주어야 함
- 이때 코어 데이터는 컨텍스트의 내용을 전부 영구 저장소에 저장하는 것이 아니라, 마지막 커밋 이후에 변경된 사항만 선별해서 반영함. → 차등 저장(Differential Save)
- 영구 저장소에 커밋이 실패했다 하더라도 현재의 컨텍스트에는 새로 생성된 객체가 남아있게 되므로, 이를 그대로 두면 실제 저장소와 일시적으로 데이터가 일치하지 않는 문제가 생김. 이를 방지하기 위해서는 catch 블록에서 컨텍스트를 롤백시켜주는 rollback() 메소드를 호출하는 것이 좋음

## 7.3.5 삭제 기능 구현하기

- 코어 데이터에서 삭제 과정은 두 단계로 이루어지며, 조금 독특한 방식으로 처리됨. 첫 번째 단계는 컨텍스트에 로딩된 특정 데이터를 삭제하는 과정이다. 정확히는 관리 객체 인스턴스를 삭제함. 영구 저장소에서 직접 데이터를 삭제하는 것이 아님. 만약 삭제하려는 값이 컨텍스트에 로딩되어 있지 않다면 영구 저장소에서 가져와 일단 컨텍스트에 로딩한 다음에 삭제해야 함
- 두 번째 단계는 컨텍스트의 변경 사항을 영구 저장소에 동기화하는 과정임. 이 과정은 “삭제”가 아니라 변경 사항을 “반영”하는 개념이기 때문에, 실제로는 데이터를 삭제하는 과정임에도 불구하고 정작 컨텍스트에서 호출하는 메소드는 save()이다.

## 7.3.6 수정 기능 구현하기

- 수정 작업은 이미 컨텍스트에 로딩되어 있는 관리 객체에서 이루어져야 함.
- 항목별로 값을 수정하면 컨텍스트에 저장된 내용도 그대로 변경되지만, 영구 저장소에는 반영되지 않기 때문에 수정 작업이 끝난 후 적절한 시점에서 save() 메소드를 호출하여 동기화시켜주어야 함

## 7.3.7 정렬 기능 구현하기

- NSSortDescriptor 객체 생성 과정에는 두 개의 매개변수가 사용됨. 첫 번째는 정렬할 칼럼, 즉 어느 어트리뷰트를 기준으로 정렬할 것인가에 대한 값이고, 두 번째는 어떤 순서로 정렬할 것인가에 Bool 타입의 값
- 생성된 NSSortDescriptor 객체는 sortDescriptors 속성에 할당됨으로써 요청 객체의 일부로 동작하게 됨. 이 속성은 배열이므로 두 개 이상의 NSSortDescriptor 객체를 정의하여 대입할 수 있음
- 첫 번째 기준에 따라 전체 레코드를 정렬한 다음, 첫 번째 정렬 칼럼의 값이 동일해서 순서를 정할 수 없는 객체들에 대해서만 두 번째 정렬 칼럼을 지정함
- 셀의 위치를 변경할 때에는 moveRow(at:to:) 메소드가 사용됨

# 7.4 릴레이션 관계를 가지는 데이터 구조 다루기

## 7.4.1 로그 저장용 엔터티 정의하기

- 클래스 메소드 fetchRequest()는 NSFetchRequest 객체를 쉽게 생성할 수 있도록 하기 위해 정의된 메소드이다.

## 7.4.5 로그 등록 기능 구현

- 게시글과 로그처럼 1:M 참조 관계에 있는 엔터티들은 1(게시글에 해당)에 속하는 관리 객체의 하위 속성에다 M(로그에 해당)에 속하는 객체 참조를 추가하는 방식으로 양쪽 데이터를 연결해 주어도 되지만, 반대로 M쪽에 해당하는 객체들이 각자 반대쪽 객체를 참조하도록 방식으로 연결해 주어도 됨

## 7.4.5 게시물별 로그 내역 화면 구현

- objectID는 NSMangedObjectID 타입의 객체로, 해당 레코드의 참조 정보를 제공하는 속성임. 이 값을 이용하면 원하는 값을 바로 읽어올 수 있음. 주의할 점은 NSManagedObjectID의 가변성이다. 인자값으로 사용되는 ObjectID 속성은 해당 관리 객체의 값이 수정될 때마다 변경될 수 있음
- array 속성은 NSSet 또는 NSOrderedSet 객체를 배열 형태로 제공하는 역할을 함
- 로그 목록 자체가 아니라 로그 목록에 대한 ‘참조’ 정보를 포함하고 있다고 이야기한 것에 유의. 로그 객체는 레퍼런스 형태로 참조되는 클래스 인스턴스이기 때문에 게시글에서도 실제로 로그 데이터 자체를 담고 있는 것은 아님
- NSPredicate 객체는 특정 조건을 만족하는 데이터만 가져오기 위해 사용된 것으로, SQL의 WHERE 조건절에 해당하는 개념

## 7.4.6 로그 내역 화면으로 이동하는 기능 구현

- 테이블 뷰는 액세서리 영역에서 탭(Tap) 이벤트가 발생했을 때 이를 별도로 감지할 수 있음. 이 이벤트는 기존의 셀 터치 이벤트와 구분되기 때문
- tableView(_:accessoryButtonTappedForRowWith:) 메소드는 사용자가 액세서리 영역을 탭했을 때 실행되는 것으로, 셀을 탭했을 때 호출되는 메소드와 충돌하지 않음. 이는 중첩된 객체에서 이벤트가 발생할 경우 자식 객체에 응답 우선권을 부여하는 코코아 터치 프레임워크의 특성 때문이다.
- iOS의 코코아 터치 프레임워크에서는 발생할 이벤트에 응답할 최초 응답자 객체를 찾기 위해 계층별로 정의된 모든 리스폰더를 차례차례 검색하는 것까지는 동일하지만, 이 중에서 최초 응답자가 발견되면 여기에다 이벤트를 전달한 후 더 이상의 계층 탐색 없이 종료됨.
- 리스폰더 체인을 사용하려면 다음과 같이 이벤트에 응답할 메소드를 정의할 때 target 속성을 nil로 넣어주면 됨  
self.button.addTarget(nil, action: #selector(onClick(_:)), forControlEvent: .touchUpInside)

# 7.5 코어 데이터 수동 반입하기

## 7.5.1 프로젝트에 코어 데이터 수동으로 반입하기

- AppDelegate의 applicationWillTerminate(_:) 메소드는 앱 델리게이트에 의해 앱이 종료될 때 호출됨

# 7.6 메모 앱에 코어 데이터 연동하기

## 7.6.1 엔터티 정의하기

- 코어 데이터는 UIImage 타입을 직접적으로 지원하지 않기 때문에, 이 타입을 사용하는 image 어트리뷰트는 NSData 타입의 바이너리 데이터로 바꾸어 저장해야 함. 코어 데이터에서 이를 지원하는 타입은 Binary Data이다.
- 이미지를 데이터베이스에 저장하는 것은 매우 무거운 작업이기 때문에 실무에서는 데이터베이스가 아닌 문서 디렉터리에 파일로 저장하고, 그에 대한 저장 경로만 데이터베이스에 저장하는 방식으로 로직을 구현하는 것이 좋음

## 7.6.2 코어 데이터 로직 구현하기

- var objectID: NSManagedObjectID?  
원본 MemoMO 객체를 참조하기 위한 속성
- 요청 객체를 생성하는 구문  
let fetchRequest: NSFetchRequest<MemoMO> = MemoMO.fetchRequest()  
스위프트의 일반적인 구문에서는 대부분의 경우에 타입 어노테이션이 생략되지만, 여기서의 타입 어노테이션은 다름. 생략했을 경우 컴파일 오류가 발생함. 이는 요청 객체를 생성하여 반환하는 fetchRequest() 메소드가 두 군데에서 정의되어 있기 때문으로, 하나는 NSManagedObject에서, 또 다른 하나는 MemoMO 클래스에서 각각 정의되어 있음. 문제는 이들 두 메소드가 오버라이드 관계가 아니며, 또한 서로 다른 타입을 반환함. NSManagedObject에 정의된 fetchRequest() 메소드는 NSFetchRequest<NSFetchRequestResult> 타입을 반환하고, MemoMO 메소드에 정의된 fetchRequest() 메소드는 NSFetchRequest<MemoMO> 타입을 반환함.
- 만약 타입 어노테이션을 누락하면 컴파일러는 어느 메소드를 사용해야 할지 알 수 없기 때문에 오류를 발생함

## 7.6.5 검색 기능 구현하기

- NSearchBar는 테이블 뷰와 함께 사용하여 특정 내용만 필터링하는 데에 이용되는 객체
- NSSearchBar는 델리게이트 패턴에 의해 동작함. 그리고 여기에 필요한 메소드는 모두 NSSearchBarDelegate 프로토콜에 정의되어 있음
- NSPredicate는 코어 데이터에서 특정 조건에 부합하는 데이터만 선택적으로 가져오기 위해 사용되는 객체
- NSPredicate 인스턴스를 생성할 때 사용되는 검색조건 표현식은 Objective-C 표준 표현시을 따르고 검색 조건 문자열 내부에 변수로 처리되어야 할 부분을 값의 타입에 맞게 %@, %K, %d 등의 표현식으로 대체하고, 이 표현식을 이어지는 바인딩 변수의 값으로 차례차례 치환하는 방식임
- 동등 비교를 할 때에는 비교 연산자 중에서 ==를 사용하는 것이 원칙이지만, =를 사용해도 무방함. 검색 조건식에서는 값의 대입이 발생하지 않으므로 =가 대입연산자로 사용되지 않기 때문
- 범위 비교가 필요할 경우에는 두 개의 조건식을 &&으로 연결하면 됨
- CONTAINS 또는 LIKE 연산자는 비교값이 포함되어 있는지 여부를 판단하는 역할을 함.
- CONTAINS[c] 연산자를 사용하면 검색에서 대소문자를 구분하지 않음
- LIKE 연산자는 특정 단어를 포함하는 값을 검색한다는 점에서 CONTAINS와 같지만, 검색어 앞 뒤로 와일드 카드를 추가할 수 있음. 사용할 수 있는 와일드 카드는 ?와 *가 있는데, ?는 한 글자의 와일드 카드를 의미하고, *는 여러 글자의 와일드 카드를 의미함.
- 애플 개발자 홈페이지에서 Predicate Format String Syntax로 검색하면 자세한 가이드 문서를 찾을 수 있음
