# CHAPTER 06 – 데이터 저장(2) – 데이터베이스와 FMDB : 대량의 데이터를 관리하는 기법

- 프로퍼티 리스트는 데이터를 쌓기보다는 단건의 데이터를 갱신하는 데에 초점이 맞추어진 저장 기술이라고 보는 것이 타당

# 6.1 데이터베이스(Database)

## 6.1.1 데이터베이스란?

- 관계형 데이터베이스 구조

## 6.1.2 데이터베이스 관리 시스템

- 데이터베이스 관리 시스템(Database Management System, DBMS)
- 사실 우리가 데이터베이스에 데이터를 저장하거나 저장된 데이터를 읽을 때에는 데이터베이스에 직접 접근하는 것이 아니라 DBMS에 접근할 뿐이고, DBMS를 통해 데이터를 간접적으로 읽고 쓰게 됨
- DB = DBMS라는 이해를 공유
- 기업명과 기업의 대표적인 제품명이 동일한 사례로, BI와 CI가 동일하다라고 표현함.
- 관계형 데이터베이스 관리 시스템(RDBMS)
- SQLite는 관계형 데이터베이스 관리 시스템이긴 하지만 서버로 분류되지 않으며, 대신 응용 프로그램의 부분적인 모듈로 동작함. 독립적인 서버로 설치해서 사용할 수 없음
- 관계형 데이터베이스는 데이터 조작을 위해 SQL이라는 문법 구문을 공통으로 사용하고, 조인(Join) 기능을 통해 데이터들이 서로 결합될 수 있는 관계를 제공함
- NoSQL은 SQL 구문을 사용하지 않고 데이터들 사이의 결합 관계를 충분히 지원하지 않는 데이터베이스
- 몽고 DB는 오픈소스 기반의 크로스 플랫폼 도큐먼트 지향 데이터베이스 관리 시스템. 플랫폼에 상관없이 사용할 수 있도록 문서 단위로 데이터를 저장하는 DBMS이고 JSON 형태로 데이터를 저장함.
- NoSQL은 단순하면서 병렬적 확장이 용이한 구조이기 때문에 분산 처리에 적합하고 빅데이터를 다루는 아키텍처에 NoSQL이 빠지지 않고 포함되는 것은 이 같은 확장성에 있음

## 6.1.3 트랜잭션(Transaction)

- CRUD : 생성(Create), 읽기(Read), 수정(Update), 삭제(Delete)
- CRUD가 기술적인 측면에서 데이터베이스 작업의 최소 단위라면, 업무적인 측면에서 데이터베이스 작업의 최소 단위는 트랜잭션이다. 트랜잭션은 하나 이상의 CRUD 작업들을 마치 하나의 실행 단위인 것처럼 묶어 주는 기능
- DBMS가 제공하는 트랜잭션은 연관된 여러 개의 CRUD 작업을 묶어 단일 작업처럼 수행할 수 있도록 해주는 기능. CRUD 작업들을 트랜잭션으로 묶으면 하나의 CRUD를 실행하는 것처럼 처리할 수 있기 때문에, 이를 논리적 작업 단위(LUW, Logical Units of Work)라고 부름
- 실행해야 할 여러 개의 단위 작업을 터널로 연결하듯 하나로 묶어 원자성을 부여함으로써 완전한 성공 또는 완전한 실패를 보장한다. 이를 통해 트랜잭션 실행 중간에 단위 작업이 하나라도 실패하면 아예 아무것도 실행되지 않은 처음 상태로 되돌리는 것이다. 트랜잭션의 최종 결과가 성공이면 그 결과를 데이터베이스에 반영하는데, 이를 커밋(Commit)이라고 하고 반대로 일부 작업이 수행되지 않아 트랜잭션 최종 결과가 실패일 경우에는 아무것도 실행되지 않았던 처음 상태로 되돌리는데, 이를 롤백(Rollback)이라고 함
- 트랜잭션의 4대 원칙 : 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)
- 원자성은 하나의 트랜잭션 내에 정의된 작업들은 모두 수행되든지, 아니면 아무것도 수행되지 않아야 한다는 기본적인 원칙. “All or Nothing”. ‘전부 실행되었거나, 아니면 아무것도 실행되지 않았거나’
- 일관성은 성공적으로 수행된 트랜잭션은 정당한 데이터만을 데이터베이스에 반영해서 무결성(integrity)을 유지해야 한다는 원칙. 데이터베이스는 트랜잭션의 전후에서 일관성 있는 데이터 상태를 유지해야 함
- 격리성은 각각의 트랜잭션은 독립성을 지녀야 하며, 하나의 트랜잭션이 실행되는 동안 트랜잭션 내부에 다른 트랜잭션이 접근할 수 없어야 한다는 원칙. 다른 말로 고립성(Isolation) 원칙이라고도 함
- 지속성은 트랜잭션이 일단 성공적으로 완료되어 데이터베이스에 커밋되고 나면, 하드웨어나 소프트웨어에 오류가 발생했더라도 트랜잭션의 결과가 데이터베이스에 계속 보존되어야 한다는 원칙

# 6.2 관계형 데이터베이스

- 관계(Relationship)란, 같은 속성 항목을 지닌 데이터들의 모임을 의미
- 관계형 데이터베이스 시스템의 조건
    - 데이터를 관계로 표현한다. 즉, 행과 열의 집합으로 구성된 여러 개의 테이블을 사용하여 데이터를 제공한다.
    - 테이블 형식의 데이터를 조작하기 위한 관계 연산자를 제공한다.

## 6.2.1 관계형 데이터베이스의 구조

- 관계형 데이터베이스가 등장하기 이전에는 대부분 데이터를 저장하기 위해 파일 시스템을 사용함
- 관계형 데이터베이스는 다양한 데이터를 분류하여 관리하기 위해 테이블을 사용
- 관계형 데이터베이스에서 하나의 테이블은 여러 개의 칼럼으로 구성되고 각 칼럼은 데이터를 하위 속성으로 나누어 저장하는 역할을 담당
- 칼럼이 가질 수 있는 값의 범위를 도메인(Domain)이라고 부르고, 칼럼에 적용되는 규칙을 제약사항(Constraint)라고 함
- 칼럼은 데이터를 저장하는 고유의 역할 외에도 데이터를 구분할 수 있는 식별자나 또는 다른 테이블의 데이터를 의미적으로 연결해주는 역할을 함. 이런 특별한 의미를 가지는 칼럼을 키(Key)라고 부름
- 데이터베이스에 입력되는 데이터들은 행 단위로 추가됨. 실무에서는 행이라는 용어보다 로우(Row)라는 용어를 더 많이 사용함
- 데이터의 형식이 바뀔 때마다 그에 맞는 새로운 칼럼이 추가되는데, 실무에서는 이를 테이블의 구조를 변경한다고 함
- 데이터 모델링 관점에서 엔티티는 공통적인 속성 항목을 가지는 데이터를 관리하기 위해 정의하는 구조를 의미함. 그리고 엔티티를 실제 데이터베이스에 적용하여 사용 가능하도록 구현한 것이 테이블이다. 엔티티를 실제로 사용할 수 있도록 구체화한 것이 테이블이고, 반대로 실재하는 테이블을 추상화한 것이 엔티티임
- 엔티티를 테이블과 거의 유사하게 실체화된 개념으로 사용하는 곳 → 코어 데이터(Core Data)
- 로우(Row)와 레코드(Record)는 테이블의 각 행 단위 데이터를 가리키는 용어이다. 각각의 레코드는 하위 속성을 구성하는 칼럼들의 집합으로 이루어지며, 서로 간에 독립적이라는 특성이 있음. 이 같은 독립성 때문에 각각의 레코드를 애플리케이션에서 다룰 때에는 특정 객체의 인스턴스로 처리하는 경우가 많음
- 칼럼(Column), 필드(Field), 어트리뷰트(Attribute)는 테이블의 하위 구조이자, 하나의 레코드를 구성하는 요소이다.
- 테이블과 로우에 어울리는 용어는 칼럼이나 필드이고 레코드와 칼럼, 레코드와 필드도 어울리는 용어 조합이다. 엔티티에는 어트리뷰트가 적절한 용어

## 6.2.2 기본 키(Primary Key)

- 데이터베이스에서는 테이블 내의 유일값, 혹은 고유값이 저장된 칼럼에 특별한 의미를 부여하는데, 이를 기본 키(Primary Key)라고 하고 다른 말로 주 키, 또는 핵심 키, PK라고 함
- 기본 키로 지정되는 칼럼의 조건
    - 조건 기본 키로 지정되는 칼럼은 값이 중복되지 않아야 함
    - 조건 기본 키로 지정되는 칼럼은 값이 비어 있거나 null이어서는 안 됨
- 위 조건을 합쳐서 유일성의 조건이라고 함
- 하나의 테이블에서 기본 키로 사용할 수 있는 칼럼이 여러 개일 경우, 이 칼럼들을 모두 후보 키(Candidate Key)라고 부름
- 후보 키들은 모두 기본 키가 될 수 있는 요소를 갖추고 있기 때문에, 이 중에서 어느 후보 키가 기본 키가 되어도 상관 없음. 하나의 테이블에는 하나의 기본 키만 지정할 수 있음
- 후보 키 중에서 기본 키로 지정된 하나를 제외한 나머지 후보 키는 모두 대체 키(Alternative Key)로 분류됨
- 기본 키로 지정하려면 칼럼이 저장하는 값이 결코 논리적으로 중복되지 않을 수 있는 값이어야 함
- 데이터 내부에서 기본 키의 요건에 맞는 칼럼을 찾기 어렵다면, 외부에서 유일값을 들여와서 기본 키로 지정할 수 있음. 대표적인 방법이 데이터베이스의 고유값 생성 기능. DBMS에는 유일값을 자동 생성해주는 기능이 대부분 포함됨. 실무에서는 유일값이라는 단어보다 유니크(Unique) 값이라는 용어를 더 자주 사용함
- 두 개의 칼럼을 합쳐서 하나의 기본 키로 지정할 수 있는데 이를 복합 키(Complexed Key)라고 부름. 복합 키는 최소한 두 개 이상의 칼럼이 모여서 만들어짐.
- 조건 기본 키로 지정되는 칼럼은 유일값을 유지할 수 있는 최소한의 칼럼으로 이루어져야 함
- 결합된 칼럼을 제거하고 또 제거해서 더 이상 제거하면 유일값이 아니게 될 만큼 최소화된 칼럼 조합이어야만 비로소 복합 키로서의 기본 키가 될 수 있음 → 최소성의 원칙
- PK를 지정함으로써 인덱스 기능 덕분에 검색 성능 향상
- PK를 지정했을 때 얻을 수 있는 또 다른 이점은 물리적 장치에 의해 무결성 원칙이 보장됨. 논리적으로 중복되지 않는 값이라 하더라도, 개발자의 실수나 강제적으로는 얼마든지 중복된 값이 입력될 수 있음. 이를 무결성이 손상되었다고 표현. 하지만 PK로 지정된 칼럼은 데이터베이스 시스템 차원에서 물리적 제약 조건을 걸어주기 때문에, 실수에 의한 값의 중복 입력까지 방지할 수 있음

## 6.2.3 정규화

- 정규화란, 관계형 데이터베이스에서 크고 제대로 조직되지 않은 테이블을 여러 개의 작고 잘 조직된 테이블로 나누는 것을 의미함. 데이터의 중복을 막고, 데이터의 갱신, 삽입, 삭제 과정에서 생기는 이상 현상을 방지하며, 데이터베이스 구조의 확장 시 테이블의 재설계 범위를 최소한으로 줄이는 것을 주 목적으로 하는 일종의 구조화 작업이라고 할 수 있음
- 데이터베이스 정규화 이론에 따라 정확하게 데이터를 분리하고, 테이블을 나누어야만 정규화 과정이라고 할 수 있음. 각 정규화 과정은 단계적이기 때문에 하위 단계의 정규화가 선행되어야 다음 단계의 정규화를 진행할 수 있음
- 정규화 과정

|정규화|의미|
|---|---|
|제 1 정규화|도메인이 원자값|
|제 2 정규화|부분적 함수 종속 제거|
|제 3 정규화|이행적 함수 종속 제거|
|BCNF 정규화|결정자이면서 후보 키가 아닌 것 제거|
|제 4 정규화|다치 종속 제거|
|제 5 정규화|조인 종속성 이용|

- 제 1 정규화 이론의 핵심은, 하나의 칼럼에 들어가는 값은 더 이상 쪼갤 수 없는 원자값이어야 함
- 제 2 정규화는 기본 키가 A + B 칼럼으로 이루어진 복합 키일 경우, 나머지 칼럼들은 A와 B 칼럼 양쪽 모두에 종속되어야 함을 의미
- 제 3 정규화는 모든 칼럼은 기본 키에 종속되어야 하며, 기본 키가 아닌 일반 칼럼에 종속되는 칼럼이 있어서는 안 된다는 조건
- 관례상 기본 키, 즉 PK는 테이블의 맨 앞에 위치하는 것이 일반적
- 정규화 과정을 충분히 거치지 않은 테이블은 비교적 잘 설계된 구조라 하더라도 데이터의 변경, 갱신, 삭제 과정에서 이상(Anomaly) 현상이 발생할 수 있음. 이상 현상은 데이터의 무결성을 해치고 데이터 구조를 엉망으로 만들 뿐만 아니라 나아가서 데이터베이스를 사용하는 응용 프로그램에 잠재적 오류를 일으킴
- 중복된 데이터에서 갱신 누락으로 인해 발생하는 불일치 현상을 갱신 이상이라고 함
- 부분적인 데이터를 삽입하기 위해 다른 칼럼을 모두 비워 두어야 하는 것은 삽입 이상에 해당함
- 일부 데이터의 삭제로 인해 원치 않는 데이터까지 함께 삭제되는 문제는 삭제 이상이라고 함
- 데이터의 중복과 이상 현상을 제거하기 위해서는 서로 다른 그룹에 속하는 데이터를 모두 분리하여 테이블을 나누어야 함
- 테이블을 분리하더라도 논리적으로는 서로 연결이 가능하도록 공통 정보를 양쪽 테이블에 남겨두어야 함
- 기본 키가 아니면서 다른 테이블을 연결해 주는 역할을 하는 칼럼을 외래 키라고 부르고 줄여서 FK(Foreign Key). 테이블을 연결해 주는 칼럼은 한쪽 테이블에서는 기본 키이지만 다른 쪽 테이블에서는 외래 키가 되는 경우가 많음
- 변경될 가능성이 있는 값 대신, 변경되지 않을 값을 찾아서 기본 키로 지정해야 함. 만약 그런 값이 없다면 임의의 코드 값을 생성해서 사용하는 것이 최선

# 6.4 SQLite3 프로그래밍

## 6.4.5 데이터베이스 파일 템플릿 사용하기

- 번들은 앱의 각종 소스 코드나 이미지 파일 등 리소스가 저장되는 곳으로, Xcode의 프로젝트에 추가한 파일은 앱 번들에서 꺼내어 읽을 수 있음. 이렇게 추가된 데이터베이스의 파일은 템플릿으로의 역할을 하게 됨
- iOS는 앱 업데이트 시 번들 영역에 저장된 파일들을 모두 덮어쓴다. 반면에 문서 디렉터리 영역은 앱 업데이트 시에도 덮어쓰는 일 없이 그대로 보존됨
- 앱이 실행되지 않은 Xcode 프로젝트 상에서 문서 디렉터리에 파일을 미리 넣어놓는 것은 불가능

## 6.4.6 리팩토링 : 코드의 가독성 높이기

- 리팩토링(Refactoring)은 소프트웨어 공학에서 사용되는 단어로, ‘결과의 변경 없이 코드의 구조를 재조정하는 것’을 의미함. 주로 가독성을 높이고 유지보수를 편하게 하기 위한 목적으로 사용되며 버그를 없애거나 새로운 기능을 추가하는 작업은 리팩토링에 해당하지 않음
- guard 구문을 사용하면 코드의 흐름을 짧게 나눌 수 있음
- 변수의 범위는 가능한 좁게 잡아주는 것이 좋음
- guard 구문에는 반드시 return과 같이 함수의 실행을 종료하는 키워드가 들어가야 함
- defer 블록은 함수나 메소드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록이다. 지연 블록이라고 부르기도 하는 이 블록에 작성된 구문은 항상 함수의 종료 직전에 실행되기 때문에, 종료 시점에 맞추어 처리해야 할 구문이 있다면 우리는 어디에 작성해야 할지 고민하지 않고 defer 블록에 넣어두기만 하면 됨. 실제로 이 블록은 함수에서 사용된 각종 리소스의 처리나 해제, 연결 종료 등의 구문을 처리하는 용도로 유용하게 사용됨
- defer 블록의 특성
    - defer 블록은 작성된 위치와 순서에 상관없이 함수가 종료되기 직전에 실행됨
    - defer 블록을 읽기 전에 함수의 실행이 종료될 경우 defer 블록은 실행되지 않음
    - 하나의 함수나 메소드 내에서 defer 블록을 여러 번 사용할 수 있음. 이때에는 가장 마지막에 작성된 defer 블록부터 역순으로 실행됨
    - defer 블록은 중첩해서 사용할 수 있음. 이때에는 바깥쪽 defer 블록부터 실행되며 가장 안쪽에 있는 defer 블록은 가장 마지막에 실행됨
- defer 블록은 항상 작성된 위치나 순서에 상관없이 함수가 종료되기 직전에 실행되는 특성을 가지는데 더 정확하게는 return 구문이 실행되기 직전에 실행됨
- 만약 defer 블록을 읽기 전에 함수가 종료될 경우 defer 블록은 실행되지 않음
- defer 블록이 실행되기 위해서는 반드시 종료 구문보다 먼저 작성되어 있어야 하며, 또한 실행 가능한 영역 내에 정의되어 있어야 함
- defer 블록은 하나의 함수 내에서 여러 번 사용할 수 있음. 여러 번 defer 블록이 정의되면 컴파일러는 가장 마지막에 작성된 defer 블록부터 가장 처음에 작성된 defer 블록으로 역순으로 읽어나가며 실행함
- defer 블록은 중첩해서 사용할 수 있는데 중첩된 블록은 가장 바깥쪽부터 차례대로 실행됨

# 6.5 FMDB

## 6.5.1 FMDB 라이브러리

- FMDB는 macOS/iOS용으로 개발된 오픈소스 SQLite3 라이브러리로, 내부적으로는 libsqlite3 라이브러리를 사용하지만 인터페이스를 모두 FMDB 라이브러리의 코드로 감싸 놓았음. 이와 같이 다른 라이브러리를 한 층의 코드로 에워싸서 재구성한 라이브러리를 래퍼 라이브러리(Wrapper Library)라고 함
- 메모리 상에만 존재하는 데이터베이스를 인 메모리 데이터베이스(In-Memory Database)라고 함

## 6.5.2 Prepared Statement

- Prepared Statement는 동일한 SQL 문을 반복 수행하는 과정에서 발생하는 비효율을 줄이고 DBMS의 성능을 향상시키기 위한 실행 방식
- Prepared Statement 방식에서는 특정 SQL 문에 대한 파싱과 실행 계획 검색, 그리고 컴파일 과정을 모두 생략할 수 있음
- 해싱(Hashing) 알고리즘이란 주어진 키(Key)에 특정 규칙을 적용하여 얻은 값으로 데이터 저장 주소를 결정하는 방식으로, 순차 검색에 비해 굉장히 빠른 검색 속도를 자랑함. 주어진 키를 통해 데이터의 위치를 바로 산출한 다음, 한 번에 접근함
- 데이터가 저장된 위치나 주소를 결정하는 데 사용되는 것이 바로 해시 함수(Hash Function)인데 이 함수의 본래 용도는 임의의 데이터를 원래의 것을 상징하는 고정 길이의 데이터로 변환하는 것으로, 이렇게 얻어진 결과값을 해시 값 또는 체크섬(Checksum)이라고 부름
- 결정론적 알고리즘은 입력값이 동일하다면 그 결과값도 동일한 것이 보장되는 알고리즘을 의미함. 이와 달리 입력값이 동일하더라도 상황에 따라 다른 값이 출력되는 알고리즘을 확률론적 알고리즘이라고 함
- 레벤스타인 거리(Levenstein’s Distance, 두 문자열의 유사도를 측정하는 알고리즘)

# 6.6 인사 관리 앱 제작하기

## 6.6.4 DAO 클래스 구현

- Data Access Object의 약자인 DAO는 데이터베이스에 SQL 문을 전송하여 질의하거나 업데이트하는 로직만 분리하여 별도의 독립적인 클래스로 구현한 것을 가리킴. 이 구조는 뷰 및 비즈리스 로직 계층과 데이터베이스 처리 계층을 구분하여 명확하게 역할을 분담해 줄 뿐만 아니라 전체 코드를 단순화하는 장점이 있음
- DAO 패턴에 따라 독립적으로 구현된 클래스를 DAO 클래스라고 하며, 주로 이름 뒤에 DAO 접미사를 붙임.
- 튜플(Tuple)은 복잡한 코드 작성 없이도 다양한 데이터를 간편하게 묶을 수 있는 매우 효율적인 자료 구조임. 별도의 클래스나 구조체가 정의되어 있지 않다는 점에서 튜플을 자료 구조나 객체가 아닌 연산자의 일종으로 보는 시각도 있음
- 튜플을 남발할 경우 가독성이 떨어진다는 단점이 있으므로 적절히 사용하는 것이 좋음. 여러 곳에서 참조해야 할 경우라면 예제에서처럼 타입 알리어스와 함께 사용하는 것이 효과적. 원하는 데이터 형식으로 튜플 타입을 정의한 다음, 이를 타입 알리어스를 통해 축약형으로 정의하여 사용
- 파일과 관련된 여러 가지 작업이 동반된다면 파일 매니저 객체를 사용하는 것이 효율적.
- 클래스의 생성자, 소멸자
- 특정 단일 레코드만 지정해서 가져올 때에는 테이블의 메인 키 칼럼을 검색 조건으로 사용하는 것이 원칙. 테이블 내에서 메인 키는 결코 중복되지 않기 때문. 또한 레코드를 가져올 때에는 주어진 입력값이 테이블 메인 키 칼럼의 어느 값과도 일치하지 않을 가능성도 염두에 두어야 함.
- 쿼우팅인 “””는 시작과 끝 모두 문자열과 분리하여 새로운 라인에서 작성해야 함. 문자열 내부에 들어가는 일반 쿼우팅(“)은 일반 문자열로 취급됨
- 열거형의 특성상 첫 번째 항목에만 정수값을 지정하면 나머지 항목은 알아서 순서대로 정수값이 지정됨
- 열거형을 사용하면 컴파일러는 입력 가능한 값의 범위를 정확하게 체크할 수 있는데 입력 가능한 값의 범위를 도메인(Domain)이라고 함
- value Object 패턴에서 VO 객체는 관련 데이터베이스 테이블을 그대로 투영하는 경우가 대부분
- 스위프트의 열거형 객체는 DB에 직접 저장할 수 없음
- VO 패턴의 객체를 정의할 때는 구조체를 사용하는 것이 좋음. 객체의 생성 및 초기화 과정이 훨신 가볍고 빠르기 때문.
- 구조체는 값을 전달할 때에는 내부의 멤버 변수에 저장된 모든 값을 복사해야 하므로 참조 주소만 전달하면 되는 클래스보다 무거움. 따라서 여러 곳에 객체를 전달해야 하는 경우에는 클래스를 사용하는 것이 좋음.
- 구조체 내부에 클래스 기반의 멤버 변수가 선언된 상태에서 값을 복사하면 클래스 기반 멤버 변수의 레퍼런스까지 함께 복사됨. 이는 복사된 객체들이 모두 클래스 기반 멤버 변수의 동일한 주소를 참조하는 결과를 가져오므로 주의해야 함
- VO 객체의 구조가 복잡해져서 공통 속성을 상위 클래스로 분리하여 상속 관계를 정의하고 싶은 경우에는 클래스를 사용해야 함. 구조체는 상속이 불가능하기 때문.

## 6.6.5 부서 목록 구현

- 튜플 선언 시 인자 레이블을 포함하면 각각의 요소를 객체 속성처럼 편리하게 사용할 수 있음. typealias Foo = (name: String, age: Int)

## 6.6.7 부서 상세 정보 및 소속 사원 정보 구현

- 함수의 매개변수에 기본값을 지정하면 매개변수 없이도 메소드를 호출할 수 있어, 메소드의 기본 형태를 그대로 사용할 수 있음
- TableView의 section 속성을 사용하면 섹션을 구분할 수 있음. indexPath.row는 섹션별로 초기화됨
- 세그먼트 컨트롤은 크기가 지정되지 않을 경우 콘텐츠에 맞추어 스스로의 크기를 최소화함
- .tag 속성은 임의로 정수값을 설정할 수 있고 기능에 영향을 미치지 않음. .tag 속성에는 오직 정수만 담아 전달할 수 있음
- iOS에서는 당겨서 새로고침(Pull to Refresh)을 쉽게 구현할 수 있게 UIRefreshControl 컨트롤을 제공함. 테이블 뷰 컨트롤러에는 이 컨트롤을 할당할 refreshControl 속성이 이미 선언되어 있는데 nil로 초기화되어 있음
- refreshControl 속성에 UIRefreshControl 객체를 할당하고 나면 다음에 할 일은 컨트롤 자체의 대상과 동작을 구현해 주는 것임. 새로고침 프로세스가 시작될 때 .valueChanged 이벤트를 보내고 이 이벤트에 액션 메소드를 지정함
- refreshControl은 테이블 뷰 컨트롤러에 이미 정의되어 있는, 새로고침 컨트롤을 위한 속성이다. 이 속성은 선언만 되어 있을 뿐 객체가 할당되어 있지 않으므로 사용을 위해서는 직접 객체를 생성하여 할당해 주어야 함
- UIRefreshControl 객체에서 사용할 타이틀을 attributeTitle 속성을 이용하여 변경하고, 새로고침 중일 때 동작할 메소드를 addTarget을 이용하여 연결해 줌
- UIRefreshControl 객체는 직접 테이블 뷰를 새로고침하는 대신 단순히 .valueChanged 이벤트를 발생시킴으로써 액션 메소드를 연결하여 호출하는 메커니즘을 제공함
- refreshControl 속성을 사용하지 않고 직접 새로운 속성을 정의하여 구현한다면 addSubView(_:)를 통해 테이블 뷰에 등록해 주어야 함
- 사용자에 의해 화면 당김이 임계점을 넘는 순간 beginRefreshing() 메소드는 자동으로 호출되기 때문에, 우리가 직접 호출해 주어야 할 것은 endRefreshing() 메소드 뿐임. 새로고침을 위한 동작이 모두 끝나고 난 후에는 endRefreshing() 메소드를 호출하여 UIRefreshControl 컨트롤의 실행을 종료해 주어야 함
- 로딩 이미지는 새로고침 컨트롤 내부에 들어갈 것이므로, 중앙 정렬을 위해 그보다 상위 객체인 refreshControl의 가로 너비를 이용함
- 로딩 이미지가 수직 중앙에 위치하려면 영역의 높이가 달라지는 순간마다 로딩 이미지의 y 좌표 위치가 교정되어야 하므로, 이를 해결하기 위해서는 스크롤이 발생할 때마다 호출되는 scrollViewDidScroll(_:) 메소드의 도움을 받아야 함
- tintColor 속성 자체를 제거하거나 nil 값을 대입할 수는 없으므로, 대신 clear 값을 대입하면 속성값이 제거됨
- scrollViewDidScroll(_:) 메소드는 테이블 뷰의 상위 컨트롤러인 스크롤 뷰 컨트롤러에 정의되어 있는 델리게이트 메소드로, 스크롤되는 동안 반복적으로 호출됨
- max(x, y)는 스위프트 아키텍처에서 제공하는 글로벌 함수로, 주어진 두 인자값 x, y 중에서 큰 값을 반환함
- 절대좌표계에서 보면 refreshControl은 제자리에 그대로 있지만 상대좌표계에서는 마이너스 좌표값을 가지게 됨
- 뷰의 변형에는 .transform 속성이 사용됨. CGAffineTransform 타입의 값을 이 속성에 적절히 설정함으로써 뷰의 형태를 찌그러트리거나 회전시키는 등의 변형을 가할 수 있음
- 뷰를 회전시킬 때에는 CGAffineTransform(rotationAngle:) 구문을 통해 생성된 값을 사용함. 이 구문은 CGFloat 타입의 값을 입력받아 회전 각도를 결정함
- bringSubView(toFront:) 메소드는 인자값으로 사용된 뷰를 가장 앞쪽으로 순서를 바꾸어주는 역할을 함
- 일반적으로 뷰는 먼저 등록된 것이 제일 뒤쪽에 위치하게 됨
- 이미지가 커지거나 작아지는 변형이 일어나면, 해당 뷰는 center 속성의 좌표가 아닌 frame 속성의 좌표를 중심으로 처리됨.
- scrollViewDidEndDragging(_:willDecelerate:)는 화면의 드래그가 끝났을 때 호출되는 델리게이트 메소드이다. 새로고침 컨트롤은 정확히 스크롤이 아니라 드래그에 의해 움직이는 것이므로 사용자가 손을 떼었을 때를 감지하기 위해서는 위 메소드를 사용해야 함
