# CHAPTER 01 – 기본 기능 다루기 : 메모장 앱 제작

# 1.1 프로젝트 생성 및 메모장 인터페이스 설계

## 1.1.1 프로젝트 생성 및 기본 설정

- iOS 10 이후로 디바이스의 개인 리소스 접근 제한이 강화돼서 앨범이나 카메라에 접근하려면 그에 대한 각각의 권한 설정이 필요하며, 이는 plist 파일을 통해 설정할 수 있음
    - Privacy – Camera Usage Description
    - Privacy – Photo Library Usage Description
- 객체의 마진(margin) : 객체 외부에 지정되는 여백, 혹은 객체 간 거리
- iOS에서 Label에 별도의 속성을 지정하지 않으면 한 줄에 표현 가능한 만큼의 텍스트만 출력하고, 출력하지 못 하는 나머지 부분은 자동으로 말줄임표로 처리됨 → 엘립시스(Ellipsis)

# 1.2 메모 앱 기능 구현

## 1.2.1 데이터 모델 작업

- 데이터 모델은 사용자가 입력한 데이터를 저장하고 이를 목록이나 상세 화면에 출력할 수 있도록 데이터 소스 역할을 하는 객체를 의미함. 주로 클래스로 정의하며 단위 데이터를 이루는 여러 속성을 프로퍼티로 선언하는 것이 일반적
- 앱의 핵심 데이터 형식을 정의하는 객체를 소프트웨어 공학에서는 데이터 모델, 또는 도메인 모델(Domain Model)이라고 함
- 배열 변수를 AppDelegate 클래스에 저장하는 것은 크게 세 가지 이슈 때문 → 접근성, 데이터 보존, 일관성
- 앱의 여러 객체가 참조하는 공유 데이터(공유 저장소)는 뷰 컨트롤러나 객체가 접근하기 쉬운 위치에 정의되어야 함. 또한, 사용 중간에 메모리 관리 이슈나 객체의 소멸로 인해 데이터가 삭제되지 않아야 하며, 여러 곳에서 사용하더라도 일관성을 유지할 수 있도록 파편화되거나 쪼개어지지 않아야 함
- AppDelegate 클래스는 전역변수를 저장하기에 적당함. 이 클래스는 앱 전체의 라이프 사이클을 관리하는 앱 델리게이트 역할을 하기 때문에, 앱 내에서 반드시 하나의 인스턴스만 존재하도록 시스템적으로 보장되어 있을 뿐만 아니라 어디서든 쉽게 접근할 수 있음. 여기에 변수를 정의하면 중복될 가능성이 전혀 없으며, 정의된 변수를 뷰 컨트롤러가 참조하기도 쉬움
- 앱 델리게이트 객체는 앱 자체의 생명 주기와 운명을 함께 함. 앱이 생성될 때 함께 생성되었다가, 앱이 소멸될 때 함께 소멸되며, 도중에 소멸되거나 새로 생성되지 않음. 즉, 한 번 생성되면 앱이 종료되기 전까지 계속 유지된다.
- 앱 델리게이트 객체에 저장되는 데이터는 어디까지나 메모리에 저장되기 때문에, 앱이 실행되는 동안에만 데이터가 유지됨

## 1.2.2 MemoFormVC 클래스 작성

- Strong 타입으로 선언되면 강한 참조, Weak 타입으로 선언되면 약한 참조.
- ARC(Auto Reference Counter)는 쉽게 말해서 ‘특정 변수를 몇 군데에서 사용하고 있는가’를 계산하는 시스템이다. 해당 변수를 어디에선가 사용하면 카운트를 +1하고, 사용이 끝나면 -1 처리하는 식으로 동작한다. 만약 변수의 카운트가 0이 되면, 그 변수는 더 이상 사용되지 않는다는 뜻이므로 iOS 시스템은 안심하고 그 변수를 제거하고 변수에 사용된 메모리를 회수하여 재사용 가능하도록 메모리 공간을 확보함. 참고로 변수를 사용한다는 것은 ‘참조한다’라고 함
- Strong 타입으로 선언된 아웃렛 변수를 어디선가 참조하면 그 순간 ARC에서 추적 가능하도록 카운트가 +1 처리됨
- Weak 타입으로 선언된 아웃렛 변수는 참조하더라도 카운트가 증가되지 않음. 따라서 사용 도중에 해당 변수가 제거되고 메모리가 회수될 수 있음
- Weak 타입이 필요한 경우는 바로 메모리가 부족하거나, 순환 참조 오류가 발생할 때이다.
- iOS에서는 메모리 부족 상황이 발생하면 ViewController에 정의된 didReceiveMemoryWarning() 메소드가 호출됨. 대부분의 경우 개발자들은 이 메소드가 호출되면 메인 뷰가 nil이 되도록 처리하는데, 이렇게 되면 메인 뷰 내부에서 Weak 타입으로 선언된 모든 변수는 카운트가 0이므로 함께 삭제됨. 이를 통해 메모리가 확보될 수 있다.
- 특정 변수를 Strong으로 선언했다면, 그리고 그 변수의 카운트가 아직 0이 아니라면 메인 뷰가 nil이 되더라도 해당 변수는 삭제되지 않고 메모리에 그대로 남아 있게 된다. 사용하지도 않는 변수가 메모리를 차지하고 있는, 이른바 메모리 누수 현상이 발생. 이런 상황을 피하기 위해, 아웃렛 변수의 참조 타입 기본값은 Weak로 권장된다.
- Weak 타입이 필요한 두 번째 경우는 순환 참조 오류가 발생할 때이다. 두 개 이상의 객체가 서로를 강하게 참조하고 있어서 객체들이 메모리에서 해제될 수 없는 상황을 의미함 → 이때 두 변수 중 어느 하나가 Weak 타입으로 참조되어 있다면 시스템은 순환 오류를 해결하기 위해 Weak 타입으로 참조된 변수를 우선 해제하면 순환 참조 사이클이 끊어지면서 나머지 변수도 참조 카운트가 0이 되어 차례대로 메모리에서 해제됨
- 내용 일부를 추출하려면 NSString 타입이 훨씬 편리하고 String과 NSString은 서로 완전 호환된다.
- NSString 타입의 문자열에서 원하는 범위만 잘라낼 때에는 substring(with:) 메소드를 사용함. 이 메소드는 NSRange 타입의 객체를 인자값으로 요구하는데, 잘라낼 문자열의 범위를 나타냄. NSRange의 초기화 구문 형태가 NSRange(location:length:)이므로, 시작 지점을 뜻하는 location 매개변수에는 0을, 길이를 뜻하는 length 매개변수에는 앞서 구한 길이값을 대입하면 우리가 필요로 하는 NSRange 객체를 생성할 수 있음
- substring(with:) 메소드는 원본 데이터는 그대로 둔 채 해당 범위의 문자열만 복사하여 새로운 문자열을 만들어 내는 방식으로 동작함
- 클로저는 일회용 함수 혹은 경량 함수라고 불리는 가벼운 함수 표현식이다.

## 1.2.6 MyMemory 앱 다듬기

- 앱이 처음 실행되면 iOS는 시작 화면부터 일단 디바이스 스크린에 출력해 놓은 다음, 메인 스토리보드의 구성을 따라 첫 번째 뷰 컨트롤러의 화면 렌더링을 시작합니다. 렌더링이 끝나면 시작 화면은 자동으로 사라지고 그 자리를 메인 스토리보드의 뷰 컨트롤러가 대신함
- 상수로 선언된 구조체는 수정할 수 없다.
- 상수로 선언해야 한다면 Array 구조체가 아닌 NSMutableArray 객체를 사용해야 하고 이 객체는 클래스 타입이어서, 상수로 선언되었더라도 값 변경에 제약이 없음
