# CHAPTER 05 – 데이터 저장(1) – 프로퍼티 리스트 : 간단한 데이터 저장하기

- 비교적 간단하고 짧으면서 키-값 (Key – Value) 형태로 단순화할 수 있는 데이터의 저장에는 프로퍼티 리스트가 사용됨. 프로퍼티 리스트는 iOS에서 기본으로 제공하는 프로퍼티 리스트를 사용하는 UserDefaults 방식과, 직접 만들어서 사용하는 커스텀 프로퍼티 리스트(Custom Property List) 방식으로 나누어짐
- 지속적으로 추가되는 데이터나 구조적인 데이터를 저장할 때에는 코어 데이터(Core Data) 또는 SQLite와 같은 데이터베이스형 객체를 사용한다.
- 일반 데이터 타입으로 표현할 수 없는 비정형 데이터를 저장할 때에는 아카이빙(Archiving)을 사용한다. 아카이빙을 사용하면 데이터 자체를 그대로 저장할 수 있으므로, 복잡한 데이터의 저장에 유리함. 아카이빙은 메모리에 저장된 데이터 자체를 그대로 저장하는 기술이기 때문에, 특정 순간 인스턴스 객체에 저장된 모든 값을 통째로 캡처(Capture)할 수도 있음. 이처럼 특정 시점에 객체에 저장된 모든 값을 캡처하는 것을 스냅샷(Snapshot)이라고 함

# 5.1 프로퍼티 리스트

## 5.1.1 프로퍼티 리스트(Property List)란?

- 프로퍼티 리스트는 애플의 주요 소프트웨어 프레임워크에 이용되는 객체 직렬화를 위한 XML 형식의 파일이다. 대부분 .plist라는 확장자를 가지기 때문에 plist 파일이라고 부르기도 하며, 애플에서는 프로퍼티 리스트를 간단한 데이터 계층을 표현하기 위한 추상화라고 정의하고 있기도 함. 비교적 단순한 데이터를 XML 포맷에 맞추어 키(Key) – 값(Value) 형식으로 저장하는 것이다.
- 객체 직렬화란, 객체의 내용을 바이트 단위로 변환하여 파일에 기록하거나 네트워크를 통해 전달이 가능하도록 하는 것을 의미한다.
- 프로퍼티 리스트는 키-값 형식을 사용하여 데이터를 저장한다. 표준 딕셔너리 데이터 구조로 각각의 키에 대응하여 데이터를 저장하므로, 데이터의 저장 위치를 알기 위해서는 키가 필요하다.
- 프로퍼티 리스트에서 하나의 키에 저장할 수 있는 데이터는 하나이지만, 이를 배열이나 딕셔너리 타입으로 정의할 경우 실질적으로 하나 이상의 데이터를 저장할 수도 있다. 그러니 하나의 키에는 하나의 객체 또는 하나의 참조값만 저장할 수 있다는 말이 좀 더 정확하다.
- 프로퍼티 리스트는 데이터의 타입을 추상화하여 저장한다. 추상화란, 정확하고 구체적인 형태를 가리키는 구체화의 반대말로서, 일체의 개별적인 특성을 배제하고 공통성을 띠는 것을 말한다.
- 프로퍼티 리스트가 객체를 저장하는 과정에서 String과 NSString, CFString 각각의 타입이 갖는 개별적이고 구체적인 특성은 모두 배제한 채 문자열이라는 공통된 특성만 추출하여 <string> 타입으로 바꾼다.
- 프로퍼티 리스트가 데이터의 타입을 추상화하는 것이지, 결코 데이터 자체를 추상화하는 것은 아니다. 데이터는 그대로 보존하되 타입만 추상화하는 것이 프로퍼티 리스트에서 데이터를 저장하는 매커니즘의 핵심

## 5.1.2 프로퍼티 리스트와 데이터 타입

- 프로퍼티 리스트에 저장할 수 있는 데이터 타입은 크게 두 가지로 구분
    - 원시 타입(Primitive Data Type) : 스위프트에서 제공하는 String, Int, Float, Double, Bool 등이 이에 해당한다.
    - 레퍼런스 타입(Reference Data Type) : 파운데이션 프레임워크에서 제공하는 NSString, NSNumber, NSDate, NSData 등이 여기에 속한다. 코어 파운데이션 프레임워크에서 제공하는 CFString, CFNumber, CFDate, CFData 등도 이 분류에 속한다.
    - Base64로 인코딩된 데이터도 프로퍼티 리스트에 저장할 수 있다. Base64란, 8비트로 된 바이너리 데이터를 문자 코드에 영향을 받지 않는 공통의 아스키 코드를 사용하여 일련의 문자열로 바꾸는 방식이다.
    - 프로퍼티 리스트에 저장할 수 있는 데이터 타입들을 공통적으로 프로퍼티 객체 타입이라고 한다. 원칙적으로 프로퍼티 객체 타입이 아니면 프로퍼티 리스트에 저장할 수 없다. 데이터의 유실 없이 프로퍼티 리스트에 저장할 수 있는 형태로 데이터를 변환하는 메커니즘이 없기 때문이다.
    - 변환 메커니즘은 NSCoder 프로토콜을 통해 제공되기 때문에, 저장하고자 하는 데이터 객체가 이 프로토콜을 구현하도록 하면 프로퍼티 객체 타입에 속하지 않아도 프로퍼티 리스트에 데이터를 저장할 수 있다.
    - 프로퍼티 리스트의 각각의 항목을 자료구조에서는 노드(Node)라고 부름
    - 딕셔너리에 추가되는 항목들은 순서가 없다. 따라서 정렬이 필요한 데이터는 배열 형식으로 저장해야 함.

## 5.1.3. 프로퍼티 리스트 작성 실습

- Root는 프로퍼티 툴에서 최상위 노드를 의미하므로 오직 하위 노드만 추가할 수 있다.
- 프로퍼티 리스트는 특성에 따라 몇 가지 타입이 존재함. 만약 최상위 노드가 Root가 아니라면 Property List Type을 None으로 변경해주면 됨
- Array나 Dictionary 타입은 하위에 데이터 집합을 담을 수 있는 대신, 객체 자신이 직접 구체적인 값을 가질 수는 없음
- Root 노드에서 (+) 아이콘을 클릭하면 무조건 하위 노드가 추가됨
- String이나 Number, Data, Date 등의 타입으로 구성된 일반 노드에서 (+) 아이콘을 클릭하면 동등한 레벨의 노드가 추가된다. 이때 추가되는 위치는 클릭된 노드 바로 다음이다.
- 배열 타입으로 되어있으면 하위 노드에는 값만 입력할 수 있고 만약 딕셔너리 타입으로 정의되어있다면 하위 노드에는 키와 값을 모두 입력할 수 있다
- 정의된 프로퍼티 리스트는 앱스토어에 앱이 등록할 때 사용되는 배포 파일인 ipa 파일에도 반입되었다가, 사용자의 기기에 앱이 설치될 때 함께 추가된다. 이때 프로퍼티 리스트가 설치되는 영역을 앱 번들(App Bundle)이라고 부르는데, 이는 주요 소스 코드와 설정 파일들이 저장되는 매우 중요한 영역이다.

# 5.2 UserDefaults

- 기본 저장소는 프로퍼티 리스트를 기반으로 하며 <앱 아이디>.plist 파일을 생성하여 XML 형식으로 데이터를 저장한다. 이 파일은 앱이 실행되는 시점에 생성된다.
- UserDefaults는 런타임(runtime) 환경에서 동작하는 객체이다. 앱이 실행되는 동안 기본 저장소에 접근하여 데이터를 가져오고 기록하는 역할을 한다.
- UserDefaults는 싱글톤 패턴으로 설계되어 있기 때문에 앱 전체에서 딱 하나의 인스턴스만 생성되며, 이 인스턴스를 앱 전체가 공유해서 사용하는 형태를 띤다.
- 동시성(Concurrency) 문제는 하나의 공유되는 자원에 여러 객체가 동시에 접근해서 사용하려고 할 때 생겨나는 문제이다. 한 객체가 값을 읽어들이는 동안 다른 객체가 값을 변경해 버린다면 이는 문제가 됨
- UserDefaults는 블로킹(Blocking)이라고 불리는 알고리즘 덕분에 UserDefaults 객체를 동시에 여러 곳에서 호출하여 데이터를 읽고 쓰더라도 순서가 꼬이거나 서로 영향을 끼칠 걱정 없이 마음 놓고 사용할 수 있다. 이것을 개발 용어로 쓰레드로부터 안전하도록(Thread-safe) 설계되어 있다라고 표현함

## 5.2.1 UserDefaults 객체의 API

- setValue(_:forKey:)는 범용 메소드이고 set(_:forKey:)는 전용 메소드이다. 메소드 오버로딩 때문에 동일한 이름을 가짐
- 메소드 오버로딩을 사용하면 하나의 이름과 형식으로 여러 타입의 매개변수에 대응하는 함수를 작성할 수 있어서 사용자의 혼란을 줄이고 일관성을 유지할 수 있다.
- 메소드 오버로딩(Method Overloading)이란, 메소드의 이름과 매개변수명은 모두 동일하되 매개변수의 타입만 다른 메소드를 여러 개 정의할 수 있는 문법이다.
- 오버로딩 문법을 활용하면 하나의 이름과 형식으로 여러 타입의 매개변수를 지원하는 각각의 메소드를 작성할 수 있으므로 타입 안정성을 높일 수 있을 뿐만 아니라, 기능에 대한 메소드명의 일관성을 유지할 수 있다.

## 5.2.2 UserDefaults 객체를 통한 데이터 처리

- standard 속성을 통해 제공되는 표준 사용자 기본 저장소에 데이터를 저장하거나 읽을 수 있다.
- UserDefaults를 통해 읽어들인 데이터는 옵셔널 타입으로 처리됨. 이것은 데이터를 읽어오는 과정에서 nil 값이 반환될 가능성이 있기 때문이다
- UserDefaults 객체는 인메모리 캐싱(In-memory Caching) 메커니즘을 사용한다. 인메모리 캐싱이란 실제 저장된 위치에서 데이터를 매번 새로 읽어들이는 것이 아니라 한번 읽어들인 데이터를 메모리에 저장해 두고 재사용하는 것을 의미한다. 프로퍼티 리스트에 저장되는 데이터들은 일반적으로 자주 갱신되지 않으므로 매번 기본 저장소를 열어 데이터를 읽어들이기보다는 메모리에 데이터를 캐싱해 두고 사용하는 것이 성능상 유리하기 때문이다.
- 인메모리 캐싱은 성능의 향상을 가져오지만, 이로 인해 기본 저장소와 메모리 간에 서로 데이터가 일치하지 않을 가능성을 항상 염두에 두어야 한다. 메모리에 데이터가 캐싱된 후에 기본 저장소의 데이터가 갱신되면 양쪽의 데이터가 서로 일치하지 않는 상황이 발생할 수 있다. 이를 현장 용어로 싱크(Sync)가 맞지 않는다라고 이야기하고, 또 다른 말로 데이터가 서로 동기화되지 않았다라고도 한다.
- 이 같은 상황을 방지하기 위해서는 UserDefaults에 데이터를 저장한 후에 반드시 캐싱된 데이터를 갱신하여 양쪽의 데이터를 일치시켜 주어야 함. 이를 동기화 처리, 또는 싱크 처리라고 부르며, 위 예제에서 마지막에 사용된 synchronize() 메소드가 이 역할을 한다. 동기화하지 않아도 별 문제가 없을 때도 있지만 언제 어디서 문제가 발생할지 알 수 없으므로 데이터를 저장한 후에는 항상 synchronize() 메소드를 호출하여 동기화 처리해 주는 습관을 들이는 것이 좋다.

## 5.2.3 UserDefaults를 사용한 데이터 저장 실습

- Dynamic Prototypes 속성이 프로토타입 셀로 구성된 외형을 프로그래밍 코드를 통해 실제 테이블 셀로 찍어내는 방식이라면, Static Cells 속성은 스토리보드에서 구성한 테이블 셀을 액면 그대로 화면으로 출력하는 방식이다.
- 세그먼트 컨트롤은 대체로 아이템 개수가 적고 아이템 이름이 짧을 때에만 제한적으로 사용됨. 아이템 이름이 길거나 개수가 많을 때에는 아이템을 세로로 나열해서 보여주는 피커 뷰(Picker View)를 사용하는 것이 훨씬 효율적
- 세그먼트 컨트롤은 하나의 아이템을 선택하면 기존에 선택되어 있던 다른 아이템이 해제되는 방식으로 동작하기 때문에, 아이템이 여러 개일지라도 그중 하나만 선택할 수 있다. 이런 특성을 잘 응용하면 탭 바의 탭과 비슷한 효과를 낼 수 있어서 종종 탭 바를 대신하여 사용되거나 또는 보조 탭 바의 역할로 사용되기도 한다.
- 오버라이드 메소드에서 부모 메소드가 처리하던 기능을 구현하고 싶을 때에는 직접 구현하기 보다는 부모 메소드를 호출하는 방식으로 기능을 구현하는 경우가 적지 않음
- 시뮬레이터에서 Shift + Command + H 키를 연달아 두 번 누르면 홈 버튼을 연속 두 번 누른 것과 동일
- 코코아 터치 프레임워크가 제공하는 UITapGestureRecognizer 제스처는 지정된 객체가 탭(Tap) 되었을 때 이를 인식하고 지정된 메소드를 호출한다.
- 뷰는 기본적으로 사용자와 상호반응하지 않도록 설계되어 있다. 이를 상호반응이 가능하도록 재처리한 것이 UIControl 클래스이다. UIControl 클래스를 상속받지 않은 일반 뷰 객체가 제스처를 사용하려면 시스템에 상호반응할 객체라는 것을 직접 알려주어야 한다. ‘User Interaction Enabled’는 이를 처리하는 옵션임.

# 5.3 커스텀 프로퍼티리스트

- 직접 생성한 프로퍼티 파일에 데이터를 저장할 수 있다.  커스텀 프로퍼티 리스트라고 하고 줄여서 “커스텀 Plist”라고 부름
- UserDefaults는 standard 속성을 통해 데이터 저장소에 바로 접근할 수 있을 뿐만 아니라 데이터의 읽기와 쓰기를 처리해 주는 전용 메소드도 사용할 수 있지만, 커스텀 프로퍼티에는 이 같은 객체와 전용 메소드가 없다. 커스텀 Plist에 데이터를 저장하려면 딕셔너리 객체를 이용하여 데이터를 정의한 다음에 이를 파일에 직접 기록해야 하고, 읽어들일 때에도 파일을 찾아 내용 전체를 읽어들인 후 딕셔너리 객체 타입으로 변환해 주어야 한다.

## 5.3.1 커스텀 Plist를 사용한 데이터 처리

- 커스텀 프로퍼티 리스트를 다루는 과정은 크게 세 단계로 이루어진다. 우선 저장된 파일로부터 내용을 읽어와서 딕셔너리 객체에 담는 것이 1단계. 이어서 필요한 것을 추가하거나 수정하는 것이 2단계, 딕셔너리 객체를 다시 파일에 기록하는 것이 3단계이다.
- iOS는 보안을 이유로 애플리케이션이 파일을 읽고 쓸 수 있는 범위를 제한하기 때문에 우리는 지정된 공간에만 파일을 저장할 수 있다. 이 공간을 샌드박스(Sandbox)라고 함. 샌드박스 안에는 문서나 데이터 파일 전용 디렉터리가 정의되어 있음. 이 디렉터리의 참조 경로는 다음 구문을 이용하여 읽어올 수 있다.  
let paths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
- NSSearchPathForDirectoriesInDomains는 해당 애플리케이션과 연관된 디렉터리 정보를 찾아 반환하는 객체이다.
- 추출된 문서 디렉터리 경로에 파일명을 덧붙이면 프로퍼티 리스트 파일의 전체 경로에 해당하는 문자열이 만들어진다.  
let plist = path.strings(byAppendingPaths: [“data.plist”])[0]  
strings(byAppendingPaths:)는 NSString 클래스에 정의된 메소드로, 기존의 경로 문자열 뒤에 인자값으로 입력받은 문자열을 붙여 하위 경로 문자열을 만들어 낸다.
- 단, 이 메소드는 경로 형식의 문자열만 생성할 뿐 실제 경로까지 만들어 주는 것은 아니므로 주의할 필요가 있다.
- 배열 아이템을 for 루프 구문의 도움 없이 직접 참조할 때에는 언제나 잘못된 인덱스 참조 오류가 발생할 가능성을 염두에 두어야 한다.
- 스위프트에서는 인덱스 0 대신 첫 번째 값을 가리키는 전용 속성인 .first를 제공한다 배열 구조체 Array에 정의되어 있는 이 속성은 반환값을 옵셔널 타입으로 전달하기 때문에 설사 배열이 비어 있다 하더라도 오류 대신 nil이 반환됨. 배열의 마지막 요소는 다음과 같이 .last 속성을 이용하여 읽어온다
- strings(byAppendingPaths:) 메소드가 인자값을 경로의 한 요소로 간주하는 특성 덕분에 결합할 양쪽 문자열 사이에는 자동으로 경로 구분 문자 “/”가 삽입됨
- strings(byAppendingPaths:) 메소드는 단순히 인자값 앞에 “/”를 추가하여 기존 문자열 뒤에 덧붙이기만 하는 것이 아니다. 인자값을 하나의 경로로 인식하고, 기본 경로와 연결할 때 “/”가 중복되지 않도록 내부적으로 처리해 주기까지 한다. 그런데 이 메소드는 NSString 객체에만 정의되어 있다.
- let data = NSMutableDictionary(contentsOfFile: plist)  
let data = NSDictionary(contentsOfFile: plist)  
이들 구문은 모두 인자값으로 입력된 문자열 경로를 통해 파일을 읽은 다음, 내용을 파싱하여 딕셔너리 형태의 데이터 객체를 생성한다.
- 만약 데이터를 읽어들이는 것만이 목적이라면 의도치 않은 데이터 변경을 방지하기 위해 NSDictionary 객체를 사용하는 것이 좋고 데이터의 변경이 필요하다면 NSMutableDictionary 객체를 사용해야 한다.
- NSMutableDictionary를 이용하여 커스텀 Plist의 데이터를 읽어온다 하더라도 기본적으로 프로퍼티 리스트의 데이터 자체는 불변이다. 딕셔너리 객체에서 값을 변경한다고 해서 프로퍼티 리스트까지 바뀌는 것은 아니라는 뜻. 딕셔너리에서 변경한 값이 프로퍼티 리스트에 반영되려면 명시적인 저장 과정을 거쳐야 한다.
- 해당 경로에 파일이 없다면 NSMutableDictionary(contentsOfFile:) 구문은 nil을 반환하면서 객체 생성에 실패한다
- value(forKey:)와 object(forKey:) 메소드는 모두 Any? 타입으로 데이터를 반환한다.
- 데이터를 입력할 때 필요한 메소드는 setObject(_:forKey:) 또는 setValue(_:forKey:)로, 저장할 값과 키를 인자값으로 넣어 호출하면 된다. 기존 값이 있다면 대체되고 기존 값이 없다면 추가되는 방식으로 동작한다.
- 보존을 위해서는 딕셔너리에 저장된 데이터를 실제 파일에 기록해 주어야 한다. 이를 위해 write(toFile:atomically:) 메소드가 사용된다. 주어진 딕셔너리 객체를 프로퍼티 리스트에 적합한 형식으로 변환한 다음, 파일에 기록한다.
- write(toFile:atomically:) 메소드의 첫 번째 인자값에는 저장할 파일 경로가 들어간다. 두 번째 인자값은 저장 과정에서 임시 파일 생성 여부를 결정한다. true면 임시 파일을 생성하여 파일을 기록하고, false라면 임시 파일을 생성하지 않고 파일을 기록한다. 이 인자값을 받는 매개변수 atomically는 atomic의 형용사형으로, 그 뜻은 원자성 여부를 나타낸다.
- 프로그래밍에서 원자성이란 더 이상 쪼갤 수 없는 명령 실행 단위를 이야기한다. 보통 기계어 수준의 명령들이 이에 해당. 일단 실행되면 끝까지 진행하거나, 혹은 아예 처음부터 실행되지 않는 식으로 동작한다는 뜻
- 이처럼 끝까지 실행되거나, 아니면 처음부터 아예 실행되지 않는 경우를 우리는 원자적이라고 표현한다. 프로세스는 기본적으로 원자성을 가지지 않기 때문에 중간에 멈추거나 일부만 실패하는 경우가 존재하기도 한다.
- 롤백과 커밋의 구현을 통해 프로세스는 원자성을 획득할 수 있다. 롤백은 오류가 발생했을 때 아무 일도 진행되지 않았던 것처럼 처음으로 되돌려 놓는 것이고 커밋은 실행이 성공했을 때에는 그대로 쭉 진행되는 것을 말함.
- 두 번째 매개변수가 true로 입력되면 이 메소드는 원본 파일에 직접 데이터를 기록하는 대신 임시 파일을 만들고 여기에 데이터를 기록한다. 만약 데이터를 기록하는 도중에 오류가 발생한다면 작업은 중단되겠지만 이는 임시 파일에만 한해 영향을 미칠 뿐이다. 원본 파일에는 아무 일도 일어나지 않는 것이다.
- 만약 오류 없이 기록이 끝났다면 임시 파일을 원본 파일로 변경한다. 대부분의 파일 시스템에서 파일의 이름을 변경하는 처리는 원자적이기 때문에 중단될 수 없다.
- 이 같은 처리 과정 때문에 두 번째 매개변수의 이름이 atomically이다. 해석하자면 데이터를 저장 장치에 기록할 때 원자적으로 기록할 것인지, 아니면 비원자적으로 기록할 것인지를 의미하는 옵션.
- 데이터 읽기를 위해서는 NSMutableDictionary(contentsOfFile:) 초기화 메소드가 사용되고 데이터 저장을 위해 write(toFile:atomically:) 메소드가 사용된다

## 5.3.2 UserDefaults vs 커스텀 프로퍼티 리스트

- 둘 모두 키-값 타입으로 데이터를 저장
- 모두 프로퍼티 리스트 형식이고 데이터 호환이 가능하다.
- 대부분은 UserDefaults를 사용하고 싶겠지만, 커스텀 Plist가 있다는 것은 이를 사용해야 할 때도 있다는 것에 대한 증거이다. 비트겐슈타인 식의 표현을 빌리자면 존재한다는 것은 어디에선가 쓰인다는 의미의 반증이다.
- 일부 기능에 국한된 데이터이거나, 저장해야 할 데이터가 너무 많아서 ‘이건 따로 그룹을 묶어서 저장해놓고 싶다’하는 생각이 든다면 커스텀 Plist로 분리하는 것이 좋음. 반면 앱 전체에서 사용되는 공통 데이터이거나 혹은 ‘plist로 분리하기엔 너무 데이터 양이 적은데, 굳이 분리해야 하나?’하는 생각이 든다면 UserDefaults 객체에 저장할 것을 권함
- 비슷한 형식의 데이터 그룹이 반복되는 경우라면 확실히 커스텀 Plist 파일을 만들어 사용하는 것이 편리함. 키의 중복 때문이다.

## 5.3.3 커스텀 프로퍼티 리스트 실습

- 피커 뷰는 크게 두 가지로 나눌 수 있다. 날짜 입력 전용으로 사용되는 데이트 피커와 일반 데이터를 입력받는 데 사용하는 일반 피커 뷰.
- 데이트 피커는 UIDatePicker 클래스이고, 피커 뷰는 UIPickerView 클래스로 구현됨
- 피커 뷰가 나타내는 목록의 가짓수는 컴포넌트(Component)라고 함
- 내부적인 기능이나 원리가 어떻게 다르건 간에 API로 다루는 방법이 비슷한 걸 인터페이스(Interface)가 유사하다라고 표현함
- 툴 바를 담당하는 클래스는 UIToolbar이다.
- 액세서리 뷰 영역은 시스템에 의해 동적으로 좌표가 정해지기 때문에 툴 바 객체에서 직접 설정하는 위치 좌표값은 큰 의미가 없다
- 툴 바는 항상 화면 폭을 가득 채우도록 렌더링되므로 너비값을 지정할 필요가 없음. 즉 높이만 설정해 주면 됨
- 툴 바는 입력된 순서에 따라 왼쪽부터 차례대로 버튼을 배치함
- Fixed Space Bar Button Item은 고정된 폭을 제공하고 정해진 거리만큼 왼쪽에서 여백을 주고 싶을 때 사용한다.
- 가변 폭 버튼은 빈 공간을 모두 채우거나 또는 자신이 들어가야 할 폭을 스스로 계산하여 자리 잡는 특성을 가짐
- 데이터를 저장하기 위해서는 가장 먼저 마스터 데이터(Master Data)를 구성해야 함. 마스터 데이터란 ‘병렬적으로 분산된 데이터들을 찾기 위한 단초가 되는 목록 형태의 가장 기본적인 데이터’를 의미하며, 일반적으로 데이터를 읽어오기 위해 아무런 검색 키워드도 필요하지 않은 것이 특징이다. 분산된 데이터를 읽어오기 위한 기초 데이터라는 의미로 시드 데이터(Seed Data)라고 부르기도 함
- 전체 설치 경로는 실행 중일 때에만 확인할 수 있으며, 이렇게 설치 경로를 확인하였더라도 이 경로는 앱 재설치 시 바뀔 수 있으므로 고정값처럼 사용해서는 안 된다.
- 터미널에서 cat은 파일의 내용을 보여 달라는 명령어다
- 템플릿(Template)을 사용하는 방식의 핵심은 모든 항목과 기본값이 정의된 표준 형식을 기본 데이터로 사용하는 것에 있다.
- 템플릿을 이용하여 생성된 프로퍼티 리스트에는 모든 항목이 들어있기 때문에 우리는 단지 필요한 항목만 덮어 쓰면 됨.
- 표준 템플릿은 항목의 추가나 편집이 용이하도록 하기 위해 수동으로 작성하여 앱 메인 번들에 추가해 두는 방식을 많이 사용함
- 메인 번들에 작성하는 프로퍼티 리스트는 Xcode에서 우리가 직접 편집할 수 있어 수정이 용이함
- main 속성은 앱의 메인 번들(Bundle) 리소스를 객체 형태로 제공함. 메인 번들 리소스 객체에서 path(forResource:ofType:) 메소드를 호출하면 번들에 포함된 특정 파일의 경로를 가져올 수 있다. 이때 forResource 매개변수에는 대상 파일의 이름을, ofType 매개변수에는 파일의 확장자를 각각 분리하여 넣어주어야 함. NSDictionary 객체는 인자값을 이용하여 읽어들인 파일을 프로퍼티 리스트 타입으로 파싱한 다음, 이를 딕셔너리 내부에 추가함. 우리가 UserInfo.plist 파일에 작성한 각 항목은 위 구문을 거쳐 딕셔너리 객체의 키와 값으로 변환되고, 최종적으로 표준 템플릿 딕셔너리가 만들어짐
- 읽기 전용의 딕셔너리 객체의 내용을 복사하여 NSMutableDictionary 객체로 만들어 주어야 이후 필요한 값을 수정할 수 있음
- 보존해야 할 데이터는 읽기 전용의 딕셔너리로 정의하여 원천적으로 값의 변경을 막고, 값을 수정해야 할 곳에서는 이를 복사하여 수정 가능한 딕셔너리 객체를 생성한 후 사용해야 함

# 5.4 미션 수행 : MyMemory 앱에 프로퍼티 리스트 적용하기

## 5.4.1 개인 프로필 정보 저장하기

- 객체지향 프로그래밍에서는 독립적인 모듈 관리 클래스에 **Manager라는 접미사를 붙이는 관례가 있다.
- Manager 객체를 사용하면 사용자 정보에 접근하는 통로가 일원화된 까닭에 최악의 경우 데이터 구조가 변경되거나 저장하는 키가 바뀌더라도 매니저 객체 내부에서만 관련 코드를 변경하면 된다. 게다가 데이터 처리 과정이 캡슐화되기 때문에, 각각의 뷰 컨트롤러들은 복잡한 과정을 거칠 필요 없이 간단한 메소드 호출이나 속성 참조만으로 필요한 데이터를 사용할 수 있다. 이는 코드의 경량화에 도움을 줌.
- 구조체 상수로 키값을 정의해 두면 독립적인 객체로 다룰 수 있다.
- 내부적으로 loginId 프로퍼티는 자기 자신에게 직접 값을 저장하는 것이 아니라 프로퍼티 리스트에 입출력되는 로그인 아이디의 처리를 대행해 주는 연산 로직에 불과하지만, 이 과정을 연산 프로퍼티로 구현해 놓으면 이후로는 이 데이터의 내부 처리에 대해 신경 쓸 필요 없이 저장 프로퍼티처럼 다룰 수 있어 편리하다.
- UIImage 타입은 프로퍼티 리스트에 직접 저장할 수 없어서, Data 타입으로 변환한 다음에 저장해야 한다. NSData 객체를 스위프트용으로 구현한 Data 객체는 Base64 인코딩 형식으로 바이너리 데이터를 변환할 수 있다. UIImage 타입을 Data 타입으로 변환하기 위해서는 UIImage::pngData() 메소드가 사용됨. UIImage(data:) 메소드를 이용하면 Data 타입을 UIImage 타입으로 변환할 수 있다.
- 프로퍼티 리스트에서 개별적으로 데이터를 삭제하는 방법이 귀찮으면 removePersistentDomain(forName:) 메소드를 사용하여 프로퍼티 리스트에 저장된 모든 값을 일괄로 지울 수 있다. 이 메소드는 인자값으로 입력된 앱 도메인(번들 아이디)에 저장된 모든 데이터를 삭제함
- 코코아 터치 프레임워크에서 UIControl을 상속받지 않은 객체는 기본적으로 사용자와 반응하지 않도록 하기 위해 .isUserInteractionEnabled 속성의 값이 false로 설정되어 있음

## 5.4.2 첫 실행 시에만 노출되는 튜토리얼 화면 만들기

- 페이지 뷰 컨트롤러(Page View Controller)는 단순하고 유사한 레이앗을 가진 페이지 여러 개를 관리하는 컨트롤러로, 스와이프(Swipe)를 통해 앞뒤 화면을 자유롭게 넘겨 볼 수 있다.
- 페이지 인디케이터(Page Indicator)는 페이징 처리를 아이콘 형태로 단순화한 것
- 앱 씨닝(App Thinning) 기술은 전체적으로 앱의 용량을 줄이기 위한 목적으로 만들어졌다. 현재 공개되어 있는 앱 씨닝 관련 기술은 비트 코드(Bit Code), 온 디맨드 리소스(On Demand Resource), 슬라이싱(Slicing)이다.
- 슬라이싱은 하나의 앱을 각각의 iOS 기기에 최적화된 형태로 설치할 수 있도록 여러 버전으로 쪼개어 제공하는 것을 의미.
- 슬라이싱 처리를 위해서는 이미지 에셋 카탈로그에 등록해 놓고 사용하는 방식으로 변경하면 됨
- 에셋 카탈로그는 해상도별 이미지 관리 목적으로 가장 많이 사용하기는 하지만, 이미지가 아닌 일반 리소스까지 모두 관리할 수 있다.
- 에셋 카탈로그는 해상도별 이미지나 리소스를 그룹 단위로 관리하는데, 이를 세트(Set)라고 지칭함.
- 에셋 카탈로그에 이미지를 넣어두고 나면 앱 등록 시 자동으로 슬라이싱 기능이 적용됨
- 클래스의 속성으로서의 역할보다는 변수라는 목적성을 더 강조하기 위해 프로퍼티라는 단어보다 멤버 변수라는 단어를 종종 쓰기도 함
- UIPageViewControllerDataSource는 페이지 뷰 컨트롤러의 데이터 소스 구현과 관련된 프로토콜. 데이터 소스란, 사용자가 페이지 뷰 컨트롤러의 화면을 앞뒤로 스와이프 할 때마다 표시될 콘텐츠 뷰 컨트롤러들을 말함
- prsentationCount(for:)와 presentationIndex(for:)는 모두 페이지 인디케이터에 페이지 정보를 알려주기 위해 사용되는 메소드
- viewDidLoad 메소드가 호출되는 시점에는 뷰가 메모리에만 로드된 상태이기 때문에, 화면 전환이 불가능. 화면 전환이 가능하려면 viewWillAppear(_:) 메소드가 호출되는 시점이어야 함. viewWillAppear(_:)는 모든 뷰가 준비되고 난 후 화면에 출력되기 직전의 상태에서 호출되기 때문에 메인 화면이 출력되기 전에 먼저 튜토리얼 화면을 띄워버릴 수 있어 자연스러운 연출이 가능하다.