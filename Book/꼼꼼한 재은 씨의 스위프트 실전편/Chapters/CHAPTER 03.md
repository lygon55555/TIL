# CHAPTER 03 – UI 커스터마이징(2) : 언제까지 기본 객체만 쓰면서 살 수는 없잖아요.

# 3.1 탭 바 커스터마이징

## 3.1.1 실습 준비

- 여러 줄의 코드를 한 줄로 줄여 작성하는 것을 인라인(Inline) 방식이라고 함
- width는 읽기 전용 연산 프로퍼티로, 내부적으로 size.width 속성을 참조한다.
- width나 frame.height는 get-only 설정이므로 값을 읽어올 수만 있을 뿐, 이 속성을 통해 값을 대입할 수는 없다. 값을 입력하려면 frame.size.width처럼 size 속성을 거쳐야 함
- sizeToFit 메소드와 center 속성 설정 구문을 함께 사용할 경우, 객체의 center 속성 설정은 항상 sizeToFit 메소드를 호출한 후에 처리하는 것이 좋음

## 3.1.2 탭 바의 이미지와 색상 커스터마이징하기

- 탭 바 아이템은 뷰 컨트롤러에서 tabBarItem 속성을 이용하여 직접 참조할 수 있다.
- 탭 바 컨트롤러에서 탭 바를 거치는 방식으로 참조하려면tabBarController?.tabBar.items?[인덱스번호]
- 탭 바 아이템과 달리 탭 바를 참조하기 위해서는 반드시 탭 바 컨트롤러를 거쳐야 함
- 선택 상태일 때의 이미지를 설정하는 속성은 selectedImage이다. 만약 selectedImage 속성이 비어 있다면 image 속성에 설정된 이미지가 selectedImage 속성의 역할까지 대신한다.
- 탭 바 컨트롤러는 연결된 모든 뷰 컨트롤러의 화면을 처음부터 생성하는 것이 아니라 각 탭이 처음 활성화되는 순간에, 다시 말해 사용자가 각 탭을 처음 눌렀을 때에야 비로소 그 탭에 연결된 뷰 컨트롤러의 화면을 읽어들인다.
- AppDelegate 클래스의 application(_:didFinishLaunchingWithOptions:) 메소드는 앱의 초기화가 완료되었을 때 시스템에 의해 자동으로 호출되기 때문에 앱에 대한 초기화 작업을 하기에 가장 적절한 위치이다.
- “전문가란, 발생 가능한 ‘거의 대부분의’ 시행 착오를 경험해 본 사람을 말한다.”
- SceneDelegate는 iOS 13부터 추가된 클래스이다. UI 라이프사이클을 관리하는 클래스임. iOS 12까지는 하나의 앱이 하나의 윈도우(Window)만 가지기 때문에 AppDelegate 클래스가 UI의 라이프사이클 관리까지 겸하고 있었는데 iOS 13부터 하나의 앱에 여러 개의 윈도우가 동시에 사용될 수 있게 됨에 따라 UI 라이프사이클을 전담 관리해줄 클래스가 필요해졌다. 이를 위해 추가된 클래스가 SceneDelegate
- 기존의 AppDelegate가 담당하던 앱의 상태 변화, 즉 앱이 실행되고 백그라운드로 들어갔다가 다시 포그라운드로 나오는 등의 변화를 대신 감지하고 그에 맞는 메소드를 호출하는 역할을 한다. 루트 뷰 컨트롤러에 대한 참조도 기존 AppDelegate 클래스에서 제공하던 것이, 이제는 SceneDelegate 클래스에서 제공하도록 변경됨
- 반면 AppDelegate 클래스는 UI 관리 역할에서 벗어나 프로세스 자체의 라이프사이클을 관리하는 역할에 집중하게 됐다. 이를 위해 앱의 데이터 구조 초기화나 푸시 알림 등의 서비스 초기화, 앱 밖에서 발생한 알림에 대응하는 등의 일을 전담한다.
- 탭 바의 tintColor, unselectedItemTintColro 속성은 순서대로 선택된 탭 바 아이템의 색상, 선택되지 않은 탭 바 아이템의 색상을 나타낸다.
- 탭 바의 backgroundImage 속성에 할당된 이미지가 배경 영역보다 작을 때, 이미지는 모자란 공간만큼 반복해서 배치된다.
- 탭 바의 색상을 설정할 때는 barTintColor 속성을 사용하는 것이 좋음. 다만 barTintColor 속성은 backgroundImage 속성과 서로 충돌하므로, 두 가지를 함께 사용할 수는 없다.
- clipsToBounds 속성을 true로 설정하면, 주어진 영역 내에서만 이미지가 표현됨. 해당 영역 내에서 이미지를 줄여 모든 부분을 표현하는 것이 아니라 영역을 벗어나는 부분의 이미지를 잘라 버린다.

## 3.1.3 탭 바 아이템에 원본 이미지 적용하기

- withRenderingMode(_:)는 이미지의 렌더링 모드를 설정하는 역할을 한다. 이 메소드는 RenderingMode 타입을 인자값으로 입력받는데, 이 값을 통해 이미지를 어떤 방식으로 렌더링 처리할 것인지가 결정됨.
    - RenderingMode.automatic : 이미지에 기본 렌더링 모드를 적용
    - RenderingMode.alwaysOriginal : 항상 원본 이미지 형태로 렌더링. 템플릿의 영향을 받지 않음
    - RenderingMode.alwaysTemplate : 항상 템플릿 이미지 형태로 렌더링 처리하고, 이미지가 가진 본래의 색상 정보는 무시함

## 3.1.4 탭 바 아이템 타이틀 커스터마이징하기

- 탭 바 아이템에서 타이틀의 크기나 색깔 등 타이틀에 관련된 속성을 커스터마이징 할 때에는 setTitleTextAttributes(_:for:)를 사용함
- 탭 바 아이템의 타이틀 속성은 딕셔너리 형식으로 설정함. 설정할 속성은 키로, 속성값은 딕셔너리 값으로 각각 지정. 속성에 대한 키는 Key 열거형에 정의되어 있는데, 이 중에서 색상을 설정하는 키는 NSAttributedString.Key.foregroundColor이다.
- 외형 프록시 객체는 화면 요소별 속성을 공통으로 적용할 수 있는 객체이다. 외형 프록시 객체에 속성을 설정해 두면, 해당 타입으로 생성된 모든 객체에 해당 속성이 적용됨. 클래스 구조에서 상위 클래스의 내용을 수정하면 하위 클래스에는 자동으로 적용되는 것과 비슷한 결과.
- 외형 프록시 객체는 대부분의 객체에서 appearance() 메소드를 통해 지원한다. 예를 들어 탭 바나 탭 바 아이템의 외형 프록시 객체를 참조할 때에는 다음과 같은 구문을 사용
    - appearance() UITabBarItem.appearance() UITabBar.appearance().tintColor = .white

## 3.1.5 탭 바 컨트롤러 직접 생성하기

- 새로운 클래스가 씬 델리게이트 역할을 하기 위해서는 몇 가지 기본 조건을 만족해야 함. 우선 UIResponder 클래스를 상속받고, UIWindowSceneDelegate 프로토콜을 구현해야 함.
- 씬 델리게이트 클래스 내부에는 UIWindow 타입의 변수가 정의되어 있어야 함. 그리고 그 변수의 이름은 반드시 window 여야 한다. 앱이 실행될 때 씬 델리게이트 클래스는 스토리보드 파일을 읽어와 윈도우 객체를 생성하는데, 이 객체를 씬 델리게이트 내의 변수 window에 저장하도록 프로그래밍되어 있기 때문이다. 참고로, 프로젝트 설정에서 스토리보드 파일을 아예 사용하지 않도록 설정한다면 굳이 window 변수를 정의하지 않아도 됨.
- 탭 바 아이템의 소유권은 탭 바가 아닌 각각의 뷰 컨트롤러가 가짐. 뷰 컨트롤러  탭 바 아이템 형태로 참조해야 된다.

## 3.1.6 탭 바 숨기기

- 알파값을 이용하여 애니메이션을 적용해 주면 자연스러운 숨김/노출 표현이 가능하다.
- 스위프트는 일급 함수를 지원하는 언어이기 때문에 함수를 인자값으로 사용할 수 있다.
- 클로저(Closure)는 스위프트의 함수 정의 구문에서 목적에 따라 불필요한 부분을 제거하고, 최대한 단순한 형태로 일회용 함수 역할을 할 수 있도록 만들어진 객체이다. 주로 인자값으로 함수가 필요한 경우, 일일이 함수를 정의하기보다는 임시로 만들어 한 번만 사용할 목적으로 정의됨
- 클로저를 만들어 가는 단계는 책 355쪽 참고
- 클로저는 재사용성이나 가독성보다는 어떻게 하면 간결하게 작성할 수 있을까를 염두에 두는 객체이다.
- 트레일링 클로저(Trailing Closure)는 간결한 코드 작성을 위해 스위프트가 제공하는 문법으로, 메소드의 마지막 매개변수가 클로저를 인자값으로 입력받는 경우 인자값의 위치에 클로저 구문을 넣지 않고, 대신 메소드 뒤쪽에 실행 블록처럼 붙일 수 있도록 하는 예외 문법이다.
- 트레일링 클로저를 사용하면 클로저를 인자값으로 하는 매개변수명은 생략되고 인자값 내부에 클로저 코드를 넣을 필요가 없으므로 코드의 가독성을 높일 수 있다는 장점이 있다.

# 3.2 내비게이션 바 커스터마이징

- 화면 이동에 관한 정보는 내비게이션 컨트롤러가 스택 형식으로 관리한다.
- 오직 내비게이션 컨트롤러를 이용하여 화면만 이동했을 때에만 내비게이션 바가 표시됨. 뷰 컨트롤러 상단에 삽입되는 내비게이션 바가 의미하는 바는 “현재 이 화면은 내비게이션 컨트롤러의 관리하에 있습니다.”
- 내비게이션 바는 내비게이션 컨트롤러의 관리를 받는 모든 뷰 컨트롤러의 상단에 표시된다.
- 만약 어느 하나의 뷰 컨트롤러에서 내비게이션 바의 속성을 수정하면 이는 모든 뷰 컨트롤러에도 적용된다.
- 내비게이션 바가 내비게이션 컨트롤러의 제어하에 있는 공통 객체인데 반해 내비게이션 아이템은 개별적인 뷰 컨트롤러의 통제를 받는 개별적인 객체이다.
- 탭 바는 탭 바 컨트롤러의 제어하에 있는 공통 객체인데 반해 탭 바 아이템은 개별 뷰 컨트롤러에 속해있는 객체이다.
- 내비게이션 바는 내비게이션 컨트롤러에 속한 객체이며, 내비게이션 아이템은 뷰 컨트롤러에 속한 객체이다. 그래서 내비게이션 아이템을 화면에 추가할 때에는 내비게이션 컨트롤러가 아니라 뷰 컨트롤러에 추가해야 하며, 참조할 때에도 역시 뷰 컨트롤러를 거쳐야 한다.

## 3.2.1 타이틀 커스터마이징하기

- titleView 속성은 UIView 타입으로 정의되어 있으며, 문자열 기반의 타이틀을 뷰 기반으로 바꿀 수 있도록 지원한다.
- 문자열 중간에 들어간 \n은 줄바꿈 문자이다. LF라고 부르는 것으로, 라인 피드(Line Feed)의 줄임말이다.
- titleView 속성에는 하나의 뷰 객체만 대입할 수 있으므로 두 개 이상의 객체로 이루어진 복합 레이아웃을 구성하려면 뷰를 하나 추가하여 컨테이너 역할로 사용하고, 그 내부를 필요한 객체들로 채워 넣으면 된다.
- 이미지 파일 뒤에 붙은 @2x, @3x란, 가로 세로 각각 두 배, 세 배씩 크게 제작되었다는 것을 나타낸다. 이 표식을 이미지 이름 뒤에 붙여 주면 iOS 시스템이 이를 인식하여 원래의 이미지를 해당하는 크기 만큼으로 줄여 표현한다

## 3.2.2 아이템 영역 커스터마이징하기

- UIBarButtonItem(customView: UIView) 위 초기화 메소드는 일반 뷰 객체를 인자값으로 입력받도록 정의되어 있음. 이는 뷰 객체를 넣은 바 버튼을 생성할 수 있다는 뜻이다.
- UIBarButtonItem 객체는 뷰가 아니므로 frame 속성을 통해 영역과 위치를 정의할 필요가 없음
- 만약 타이블 뷰를 중앙이 아니라 좌측 또는 우측으로 몰고 싶다면 좌우측 아이템을 제거하거나 비워두면 된다.

# 3.3 알림창 커스터마이징

## 3.3.2 UIAlertController의 커스터마이징 원리

- 퍼블릭 API, 프라이빗 API
- 기본 형태에서는 콘텐츠 뷰 컨트롤러가 비어 있기 때문에 거의 보이지 않다시피 하지만, 우리는 이 영역을 이용하여 알림창을 커스터마이징할 수 있다.
- 원하는 뷰 컨트롤러를 구현하여 UIAlertController에 넣을 수 있다.

## 3.3.4 콘텐츠 뷰 컨트롤러 영역 확인하기

- 알림창에 사용되는 콘텐츠 뷰 컨트롤러에 특별한 타입 조건이 있는 것은 아니다. UIViewController 클래스를 상속받은 어떤 컨트롤러라도 상관없음
- setValue(_:forKey:) 메소드를 사용하여 UIAlertController 객체의 속성에 값을 설정하는데, 우리가 사용할 속성은 contentViewController이다.
- contentViewController 속성은 프라이빗 API로 정의되어 있기 때문에 자동 완성 기능이 지원되지 않는다.
- 알림창은 타이틀 속성이 nil일 때, 해당 공간을 비워두는 것이 아니라 아예 지워버림. 따라서 타이틀 속성을 nil로 처리하면 그만큼의 공간이 줄어드는 효과가 있다. 이 점은 메시지 속성도 마찬가지.
- 텍스트 필드 영역은 .alert 속성일 때에만 사용 가능하다. 만약 알림창에 텍스트 필드를 추가한 채로 preferredStyle 인자값을 .actionSheet로 변경하면 런타임 오류가 발생

## 3.3.5 맵을 넣을 알림창 만들기

- 루트 뷰로 지정한 경우에는 뷰 자체에 설정한 너비와 높이는 아무 의미 없는 값이 된다. 루트 뷰는 항상 화면 전체를 채우는 방식으로 크기가 자동 지정되기 때문이다. 루트 뷰일 경우 항상 기본 좌표는 (0, 0)이며, 설령 다른 값을 설정해 두었다 하더라도 루트 뷰로 지정된 경우 기존에 설정된 좌표값은 모두 무시된다.
- 알림창은 contentVC 객체의 정보를 읽어들일 때 preferredContentSize 속성을 참고하여 표현해야 할 크기가 얼마인지 계산한다.

## 3.3.6 이미지가 포함된 알림창

- 이미지 뷰는 뷰의 일종이므로 화면에 나타내기 위해 영역 정의가 필요함
- preferredContentSize 속성을 통해 외부 객체가 ImageViewController를 나타낼 때 참고할 사이즈를 지정한다. 높이값을 지정할 때 원래의 이미지 높이 + 10으로 처리하는 것은 알림창에 이미지가 표시될 때 이미지 아래에 여백을 주기 위한 것으로 이해하면 된다.

## 3.3.7 컨트롤이 사용된 알림창

- 연산 프로퍼티는 본래 get 구문과 set 구문을 이용하여 값의 읽기 / 쓰기를 지원하지만 읽기 전용의 연산 프로퍼티를 정의할 때에는 set 블록을 생략할 수 있다. 또한 set 블록을 생략하면 남은 블록은 get 블록밖에 없으므로, get 키워드도 생략할 수 있다. 연산 프로퍼티 내에 get/set 구문이 없다면 모두 get 구문으로 간주하면 됨
- 일반적으로 뷰 컨트롤러에 추가된 객체는 외부에서 참조할 수 없도록 처리하는 것이 좋음. 객체를 외부에서 직접 참조하는 것은 여러 가지 문제를 일으킬 수 있기 때문이다.
- 제한적으로 필요한 부분만 제공할 수 있도록 연산 프로퍼티를 사용하는 것이 보다 안전하기 때문에 이처럼 프로퍼티를 이용하는 것이다.

## 3.3.8 알림창에 테이블 목록 넣기

- 델리게이트 패턴은 코코아 터치 프레임워크에서 기본으로 다루고 있는 패턴일 뿐만 아니라, 공식적인 참조 관계가 없는 객체에서 발생하는 이벤트를 전달하는 방법이다.

# 3.4 커스텀 클래스

## 3.4.1 커스텀 클래스의 원리

- 커스터마이징 대상이 가지는 기본 기능은 부모 클래스의 것을 그대로 물려받고, 필요한 기능만 추가로 구현하거나 오버라이드 할 수 있다.
- 상속받는 클래스의 API 구조를 확인하여 viewDidLoad와 비슷한 효과를 낼 수 있는 메소드를 찾고, 이를 이용해야 함

# 3.5 커스텀 클래스(1) – 커스텀 버튼

## 3.5.1 기본적인 커스텀 만들기

- init(coder:) 구문은 스토리보드 방식으로 객체를 생성할 때 호출되는 초기화 메소드이다.
- 스토리보드에서 사용하는 초기화 메소드는 init(coder:)로 규격화되어 있고 스토리보드에서는 오직 이 형식의 초기화 메소드만 호출함
- zero는 모든 프로퍼티의 초기값이 0인 CGRect 객체를 의미함. 주로 정확한 값이 없는 상태에서 CGRect 객체를 초기화할 때 많이 사용함

## 3.5.2 커스텀 클래스 제작 시 알아두어야 할 상속과 초기화 메소드

- 프로퍼티를 선언하기만 하면 자동으로 0 또는 nil로 초기화되는 오브젝티브-C와 달리, 스위프트에서 저장 프로퍼티의 자동 초기화는 옵셔널 타입으로 선언된 경우에만 제한적으로 허용된다. 따라서 옵셔널 타입으로 선언되지 않은 저장 프로퍼티는 반드시 명시적으로 초기화해 주어야 한다.
- 명시적인 초기화란, 다음 두 가지 경우 중 한 가지를 의미
    - 저장 프로퍼티를 선언할 때 초기값을 함께 지정하는 경우
    - 초기화 메소드 내에서 저장 프로퍼티의 초기값을 지정하는 경우
- 스위프트에서 옵셔널 타입으로 선언되지 않은 모든 저장 프로퍼티는 인스턴스가 생성되기 전에 반드시 초기값이 설정되어야 한다. 옵셔널 타입으로 선언된 저장 프로퍼티는 초기값이 없을 경우 자동으로 nil로 초기화된다.
- 구조체에서는 내부적으로 정의된 모든 저장 프로퍼티를 초기화해 주는 초기화 메소드가 자동으로 제공된다. 이를 멤버와이즈(Memberwise) 초기화 메소드라고 하는데, 저장 프로퍼티를 일반적으로 객체의 멤버 변수라고 부르는 데에서 유래한 이름. 멤버와이즈 초기화 메소드는 모든 멤버의 초기값을 인자값으로 입력받고, 이 값을 각 멤버 변수에 대입하여 초기화한다.
- 멤버와이즈 초기화 메소드를 이용하면 손쉽게 프로퍼티를 모두 초기화할 수 있다.
- 저장 프로퍼티의 일부가 초기화되지 않았을 경우 초기화 메소드를 통해 명시적으로 초기화해야 한다는 뜻이다.
- 만약 클래스의 모든 멤버가 초기화되어 있다면 클래스 객체가 묵시적으로 제공하는 기본 초기화 메소드를 사용하여 인스턴스를 생성할 수 있다. 여기서 말하는 기본 초기화 메소드란 어떤 매개변수도 갖지 않는 init() 메소드를 의미한다.
- 상속 관계에 있을 때에는 초기화 메소드를 주의해서 사용해야 한다. 부모의 초기화 메소드는 자식 클래스에 추가된 새로운 저장 프로퍼티를 초기화하지 못하므로, 이를 그대로 상속받아 사용할 경우 초기화되지 않는 저장 프로퍼티가 생길 수 있다. 이를 방지하기 위해 일반적으로 부모의 초기화 메소드는 일반적으로 자식 클래스에게 상속되지 않는다.
- 부모의 저장 프로퍼티를 직접 초기화하기보다는 부모 클래스의 초기화 메소드를 호출하여 간접적으로 초기화하는 방법을 많이 사용한다.
- 부모의 초기화 메소드를 호출한 것이 이들의 호출 관계를 따라 최상위 클래스에 이르는 모든 저장 프로퍼티가 차례로 초기화되는 것을 초기화 메소드의 델리게이션(Delegation)이라고 한다.
- “모든 멤버(저장 프로퍼티)는 적절한 초기값을 가지고, 누락 없이 완전히 초기화되어야 한다.”
- 스위프트의 초기화 메소드는 지정 초기화 메소드와 편의 초기화 메소드로 나누어짐. 이들은 일정한 규칙에 의해 초기화 체인(Initializer Chain)이라는 관계를 구성하면서 메소드 사이의 코드 중복을 최소화한다.
- 지정 초기화 메소드(Designated Initializer)는 클래스의 메인 초기화 메소드다. 초기화 과정에서 해당 클래스의 모든 멤버, 즉 저장 프로퍼티를 초기화해야 하는 의무를 가진다. 따라서 이 메소드는 현재의 클래스에서 새롭게 정의한 모든 저장 프로퍼티의 초기값을 설정하고, 이어서 부모의 초기화 메소드를 호출함으로써 상속받은 모든 저장 프로퍼티까지 초기화한다.
- 클래스는 지정 초기화 메소드의 수를 최소화하려는 경향이 있기 때문에 여러 개의 초기화 메소드가 있더라도 지정 초기화 메소드는 보통 하나인 경우가 많다. 이때 코드의 중복을 줄이기 위해 다른 초기화 메소드들은 모두 내부적으로 지정 초기화 메소드를 호출하는 이른바 깔때기 모양의 호출 구조를 만들어 낸다. 현 단계에서 새롭게 추가한 저장 프로퍼티를 위해 추가적인 초기화가 필요 없을 경우에는 부모로부터 몇 개의 초기화 메소드를 상속받는 것만으로 이 같은 구조를 만들어 낼 수 있게 되는데, 이를 자동 초기화 메소드 상속이라고 한다.
- 편의 초기화 메소드(Convenience Initializer)는 사용에 편의를 주기 위해 정의하는 보조적인 초기화 메소드이다. 이 메소드는 일부 혹은 전체 멤버에 대해서 별도의 초기값을 설정하는 동시에, 내부적으로 다른 초기화 메소드를 다시 호출한다. 반드시 정의해야 하는 것은 아니며, 지정 초기화 메소드와 구분을 위해 convenience 키워드를 붙여준다.
- 클래스 초기화 과정에서 편의 초기화 메소드는 같은 클래스 내에 정의된 다른 초기화 메소드를 호출하는 식으로 연쇄 초기화를 시도하는데, 이 과정에서 최종적으로는 지정 초기화 메소드가 호출되어야 한다. 부모 클래스의 지정 초기화 메소드를 호출하여 상속받은 모든 저장 프로퍼티를 초기화하는 것은 지정 초기화 메소드만의 고유한 역할이다.
- 원리
    - 지정 초기화 메소드는 항상 상위 방향으로 호출한다.
    - 편의 초기화 메소드는 항상 수평 방향으로 호출한다.
- 부모 클래스와 동일한 형식의 지정 초기화 메소드를 정의하면 이것은 오버라이드하는 것으로 간주되므로, override 키워드를 붙여 주어야 한다. 또한 초기화 메소드 내부에서 부모의 동일한 초기화 메소드도 호출해 주어야 한다.
- 편의 메소드는 상위 호출이 금지되어 있다. 편의 초기화 메소드 앞에는 override 키워드를 붙일 수 없다.
- required 키워드를 초기화 메소드 앞에 붙이면 필수 구현 메소드가 되므로, 이후로 모든 자식 클래스들은 해당 초기화 메소드를 반드시 구현해야 한다.
- 자동 상속이 성립할 조건은 ‘지정 초기화 메소드의 추가 여부’이다. 지정 초기화 메소드를 추가하지만 않는다면 편의 메소드를 얼마든지 추가하더라도 여전히 부모 클래스로부터 지정 초기화 메소드를 상속받을 수 있다.

## 3.5.3 스타일을 선택할 수 있는 버튼 만들기

- didSet은 프로퍼티 옵저버이고 특정 프로퍼티의 값이 변할 때마다 자동으로 호출된다. 프로퍼티의 값 변경을 감시하는 이벤트 리스너라고 할 수 있다.
- didSet이 프로퍼티의 값이 변경된 직후에 수행되는 블록이라면, willSet은 프로퍼티의 값이 변경되기 직전에 수행되는 블록이다.
- 객체 내부의 클래스에서 작성한 액션 메소드는 뷰 컨트롤러에서 연결한 것과 달리 해당 타입을 사용하는 모든 곳에 일괄로 적용된다.
- 커스텀 클래스에서 정의한 액션 메소드와 뷰 컨트롤러에서 정의한 액션 메소드는 양립 가능하다. 커스텀 클래스에서 액션 메소드가 정의되었다 하더라도 뷰 컨트롤러에서 또 다른 액션 메소드를 작성할 수 있으며, 이 경우 양쪽의 액션 메소드가 모두 실행된다.
- 액션 메소드를 지정할 때는 addTarget(_:action:for:) 메소드를 사용한다.
- 화면에서 버튼이 어떤 용도로 사용되는가에 관계없이, 커스텀 버튼 자체의 기능을 구현할 목적이거나 또는 모든 버튼 객체에 일괄로 기능을 적용해야 할 때에는 커스텀 클래스 내부에 액션 메소드를 정의하는 것이 좋음.
- 버튼의 개별적인 사용 목적을 위해 액션 메소드를 구현할 때에는 커스텀 클래스 외부에 액션 메소드를 정의하는 것이 좋다. 가령 화면을 이동하는 처리나 데이터를 저장하는 기능 등은 버튼이라는 타입 자체의 기능이 아니라 개별적인 버튼이 담당하는 역할이다. 비즈니스 로직에 관련된 기능은 가급적 커스텀 클래스 외부에 작성하는 것을 원칙으로 하는 것이 좋다.
- 목적에 따라 코드의 작성 위치를 구분하는 것을 소프트웨어 공학에서는 관점 지향 프로그래밍(Aspect Oriented Programming, 이하 AOP)이라는 개념으로 다룬다. 서로 다른 목적의 코드는 서로 다른 위치에 작성하여 관점별로 코드를 분리하는 것이다.
- 핵심 로직에서 벗어나는 관점을 가진 나머지 코드들은 가급적 눈에 띄지 않는 위치로 옮기거나 캡슐화 처리를 하기도 하고, 또는 메소드 외부에서 전처리 혹은 후처리를 하는 등의 다양한 방법을 연구한다. 객체 지향 프로그래밍(Object Oriented Programming)의 현실적 한계를 직시하고 이를 보완하기 위한 개념으로 탄생했다.

# 3.7 커스텀 클래스(3) – 커스텀 스테퍼

## 3.7.1 실습 준비

- private과 fileprivate은 모두 해당 객체를 외부로부터 숨기는 역할을 한다. 그러나 private으로 선언된 객체는 같은 클래스 범위 내에서만 접근이 가능한 반면, fileprivate으로 선언된 객체는 클래스가 다르더라도 같은 파일 내에서 정의되어 있다면 접근할 수 있다는 차이가 있다.
- public과 open은 모두 해당 객체를 모듈 외부에 공개하는 역할을 한다. 그러나 public으로 선언된 객체는 상속받거나 멤버 객체를 오버라이드할 수 없다. 오로지 참조하여 사용하는 것만 허요오딘다. open으로 선언되었다면 상속과 오버라이딩 모두 허용됨.
- 만약 접근 제한자를 선언하지 않고 클래스나 메소드, 프로퍼티를 정의하면 컴파일러는 기본적으로 internal 범위를 적용한다.
- 공개/비공개로 구분된 API들은 public과 private 등 접근 제한자에 의해 나누어진 결과이다.

## 3.7.2 유저 인터페이스 구현하기

- 뷰의 크기 변화에 따라 내부 객체의 크기를 조절하는 방법에는 크게 두 가지가 있다. 하나는 제약 조건을 걸어 자동 레이아웃을 설정하는 방법이고, 또 다른 하나는 layoutSubviews 메소드를 사용하는 방법이다.
- layoutSubviews 메소드는 뷰의 크기가 변할 때 호출되는 메소드이다. 뷰의 내부에 다른 객체들이 있다면, 이 메소드 내부에 객체의 크기를 조절하는 구문을 작성함으로써 뷰의 크기 변화에 적절히 대응할 수 있다.
- 메소드를 오버라이드하더라도 딱히 부모 메소드의 기능 자체를 폐기할 목적이 아니라면, 내부에서 부모의 동일 메소드를 호출해주는 것은 좋은 습관이다.
- @IBDesignable 어트리뷰트는 이 클래스를 스토리보드에서 미리보기 형태로 처리해 달라고 시스템에 요청하는 역할을 한다. 이 어트리뷰트가 붙은 클래스가 스토리보드의 객체와 연결되면 인터페이스 빌더는 클래스의 내용을 미리 실행하여 유저 인터페이스를 구현한 다음, 이를 스토리보드에 표시한다.

## 3.7.3 스테퍼 기능 구현

- 옵저버 블록에서 변경되기 전의 값을 참조하려면 oldValue라는 변수를 사용하면 된다.

## 3.7.4 커스터마이징을 위한 속성 추가하기

- @IBInspectable은 우리가 정의한 속성을 인터페이스 빌더에서도 설정할 수 있도록 처리해주는 어트리뷰트이다. 이 어트리뷰트가 붙은 프로퍼티는 어트리뷰트 인스펙터 탭의 속성 항목에 추가되어 편집 가능한 상태로 표시된다.
- @IBInspectable 어트리뷰트를 사용하기 위해서는 프로퍼티에 타입 어노테이션이 선언되어 있어야 한다.

## 3.7.5 추가 개선 사항

- sendActions(for:)는 인자값으로 입력된 타입의 이벤트를 발생시키는 메소드이다.

# 3.8 미션 해결! MyMemory 앱의 커스텀 클래스 구현하기

## 3.8.2 MyMemory 커스터마이징

- clear는 UIColor 개체가 제공하는 색상 중 하나로, 아무 값도 설정되지 않은 빈 색상이다.
- 줄 간격을 설정할 때에는 NSMutableParagraphStyle 클래스의 lineSpacing 속성을 사용한다. NSMutableParagraphStyle은 문단 스타일을 정의하는 클래스이다.
