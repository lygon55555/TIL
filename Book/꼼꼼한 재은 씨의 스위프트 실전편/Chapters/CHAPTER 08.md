# CHAPTER 08 – 서버 연동

# 8.1 서버 연동을 위한 기초 이론

## 8.1.1 HTTP 메시지

- HTTP 메시지는 크게 요청과 응답 메시지로 나뉨. 각각의 메시지는 모두 라인 – 헤더 – 바디의 세 부분으로 구성됨. 라인(Line)은 HTTP 메시지의 맨 첫 줄에 해당하는 영역으로, 메시지의 가장 기본적인 내용인 응답/요청 여부, 메시지 전송 방식, 상태 정보 등이 작성되는 곳임. 그 아래로 헤더(Header)에는 메시지 본문에 대한 메타 정보가, 바디(Body)에는 실제로 보내고자 하는 메시지 본문 내용이 들어감
- 라인 영역은 반드시 한 줄로 작성되어야 함. 헤더와 바디의 길이는 유동적이므로, 두 영역 사이에는 구분을 위한 한 줄의 공백이 들어감
- 메시지의 제일 첫 줄은 무조건 라인 영역이며, 이어지는 내용들은 공백 한 줄이 나타날 때까지 모두 헤더로 간주하면 됨. 공백 한 줄에 이어서 작성된 나머지 모든 내용들은 메시지 본문으로 처리함
- 흔히 Request라고 부르는 요청 메시지는 GET/POST 등의 전송 메소드를 정의하는 데에서 시작함. 이 값은 이 메시지가 어떤 전송 방식으로 구성되어 있는지를 나타냄. 뒤이어 작성되는 것은 요청 내용에 대한 경로이며, 그 다음은 요청 형식에 대한 버전 정보임.
- 헤더는 모두 키 : 값으로 이루어짐. Host 헤더에는 도메인 및 포트 번호가 포함되어 있는데, 이는 두 개 이상의 도메인에 연결되어 있는 서버일 경우 어느 도메인으로 요청이 들어왔는지 구분하기 위함임
- Content-Type은 메시지 본문이 어떤 형식으로 작성되어 있는지를 나타냄. 우리가 API 연동을 위해 사용할 메시지 본문 형식은 JSON인데, 이때에는 Content-Type 헤더의 값을 application/json으로 설정해 주어야 함
- 한 줄 공백 아래에 작성된 메시지 본문의 형식은 헤더의 Content-Type에 설정된 타입과 일치해야 함
- URLEncoding이란, URL 전송에서 사용되는 @, & 등의 특수 문자가 전송하려는 값 내에도 포함되어 있을 때, 이를 겹치지 않는 다른 특수문자 형식으로 변경하는 것을 의미함
- GET 방식에서는 파라미터를 모두 URL 뒤에 연결해서 전달하고 이렇게 연결된 파라미터를 쿼리 스트링(Query String)이라고 함
- 메시지 본문을 사용하지 않기 때문에 GET 방식에서는 Content-Type 헤더가 사용되지 않음
- HTTP 메소드의 종류

|메소드(전송 방식)|목적|
|---|---|
|GET|특정 리소스의 대표적인 정보를 요청할 때|
|POST|ID 없이 리소스를 생성하거나 수정할 때|
|PUT|ID 기반으로 리소스를 생성하거나 수정할 때|
|DELETE|리소스를 삭제할 때|
|HEAD|GET 방식의 요청이지만 내용 없이 메타정보만 요청할 때|
|OPTIONS|특정 URL에 대한 보조 메소드 역할|

- 누군가 패킷을 훔쳐보는 걸 스니핑(Sniffing) 공격이라고 함. 금융이나 개인 정보 교환처럼 서버와 클라이언트 간의 메시지가 보호될 필요가 있을 때에는 인증서를 통해 패킷을 암호화한 다음에 전송하게 되는데, 이를 가리켜 HTTPS라고 부름. HTTP+S(Security)가 합쳐진 단어로, 여기에 적용되는 보안 인증에는 SSL 인증, 또는 TLS 인증 등 다양한 버전이 존재함
- HTTPS 인증의 핵심은 메시지를 암호화한 후 전달함으로써, 중간에서 데이터를 훔치더라도 열어 볼 수 없도록 보호하는 것에 있음
- 보안 통신을 하고 싶다면 적절한 수준의 인증서를 구매하여 해당 도메인 또는 서버에 적용해 주어야 함

## 8.1.2 RESTful API

- REST는 Representational State Transfer의 첫 글자를 딴 것으로, HTTP를 위한 아키텍처의 한 형식임. REST란 웹 콘텐츠나 데이터를 HTTP 기반으로 간단히 주고 받기 위해 정의된 간단한 형식의 인터페이스를 말함
- REST 구조를 따라 구현된 시스템을 RESTful 이라고 부름
- RESTful 기반으로 서버에서 요청과 응답을 주고 받을 수 있도록 정의된 형식을 RESTful API라고 함
- RESTful API는 메시지 본문을 JSON 형식으로 구성하여 보냄
- JSON은 JavaScript Object Notation의 약자로서 자바스크립트 언어에서 객체의 속성을 표현하기 위한 방법으로 사용하기 시작한 데이터 구조
- JSON에 사용되는 데이터 구조는 크게 두 가지 종류로 나눌 수 있음. 하나는 여러 가지 속성을 키 – 값 형태로 정의할 수 있는 집합 구조이며, 또 다른 하나는 비슷한 성격의 객체가 반복되는 리스트 구조이다. 집합 구조를 정의할 때에는 중괄호가 사용되며, 리스트 구조를 정의할 때에는 대괄호가 사용됨. 집합 구조는 JSON 객체라는 이름으로 사용되고, 리스트 구조는 JSON 배열이라는 이름으로 사용됨.

|명칭|형식|구분|
|---|---|---|
|JSON 객체|{ 키 : 값, 키 : 값 .. }|여러 속성을 정의하는 순서 없는 집합|
|JSON 배열|[ 객체 1, 객체 2, 객체 3]|비슷한 객체가 반복 나열되는 순서화된 리스트|

- JSON 객체는 { 키 : 데이터 } 형태로 이루어진 K – V 구조의 데이터 집합이다. 딕셔너리 객체와 같은 성격임.
- JSON 객체에서 일반적으로 키(Key)는 문자열만 사용하지만, 값(Value)에는 문자열 이외에 정수나 실수, 논리값도 사용할 수 있음. 다만 정수나 실수, 논리값을 표현할 때에는 따옴표를 붙이지 않으며, 문자열을 표현할 때만 큰따옴표를 붙여줌
- 문자열 앞뒤로 따옴표를 붙여주는 처리를 쿼우팅(Quoting)이라고 함. 큰 따옴표를 붙여주는 것을 더블 쿼우팅, 작은 따옴표를 붙여주는 것을 싱글 쿼우팅이라고 함
- 스위프트에서 JSON 객체를 다룰 때에는 딕셔너리(Dictionary) 계열의 자료형을 사용함. 단, 스위프트의 기본 자료형인 Dictionary 객체는 동일한 타입의 데이터만 저장할 수 있다는 제약이 있기 때문에 보통은 값의 타입을 범용 형식인 Any로 정의해서 사용하는 경우가 많음
- 파운데이션 프레임워크에서 제공하는 NSDictionary, NSMutableDictionary 타입을 통해 JSON 객체를 다룰 수도 있음.
- 일반적으로 Mutable 키워드가 붙은 자료형이 함께 제공된다면, Mutable 키워드가 붙은 쪽은 편집이 가능한 반면 붙지 않은 쪽은 편집이 불가능하다는 차이가 있음
- 목록 형태의 데이터를 처리하기 위해서는 리스트, 즉 배열 구조가 사용되고 이를 JSON 배열이라고 부름
- JSON 배열 내부에 들어가는 항목을 아이템이라고 표현함

# 8.2 파운데이션 프레임워크를 이용하여 API 호출하기

## 8.2.1 GET 방식으로 현재 시간 확인용 API 호출하기

- 종종 디바이스의 시간 설정을 변경하여 아이템 획득 쿨타임을 우회하려는 어뷰징 시도가 발생하는데, 이때 서버의 현재 시간과 디바이스에 설정된 시간을 비교하는 로직을 추가하면 디바이스의 시간을 변경했더라도 손쉽게 어뷰징 시도를 무위로 돌릴 수 있음
- REQ는 Request(요청)을 표시하는 의미. RES는 Response(응답)을 표시하는 의미
- 데이터를 주고받을 서버가 HTTPS 프로토콜을 사용한다면 ATS를 설정하지 않아도 됨. HTTPS 프로토콜은 데이터 패킷을 모두 암호화하여 전송하므로 보안상 안전하기 때문
- 코코아 터치 프레임워크가 제공하는 GET 방식의 호출구문들
    - let result0 = try! Data(contentsOf: url!)
    - let result1 = try! String(contentsOf: url!)
    - let result2 = try! NSString(contentsOf: url!, encoding: String.utf8.rawValue)
- Data(contentsOf:)는 Base64 인코딩된 문자열을 반환하기 때문에, 보통 바이너리 데이터를 읽어올 때 사용함. 예를 들면 이미지 같은 것. 반면 String(contentsOf:)는 일반 문자열을 반환하므로 지금처럼 서버가 문자열을 바로 반환할 때 사용하는 것이 편리함
- NSString(contentsOf:encoding:)은 반환 타입이 NSString이라는 것 외에는 String과 동일하지만, UTF-8 등으로 인코딩을 지정해야 할 필요가 있을 때 사용됨. 가령 응답 결과에 한글이나 한자 등 2바이트를 사용하는 언어가 포함되어 있을 때가 대표적

## 8.2.2 POST 방식으로 API 호출하기

- Content Type은 POST 방식으로 서버에 값을 전송할 때 URL 인코딩된 폼 타입을 사용하겠다는 의미
- GET 방식에서 쿼리 스트링은 URL의 일부에 포함되어 전송되지만, POST 방식에서 이 값은 다음과 같이 HTTP 메시지의 본문 내용에 담겨 전송됨
- 스위프트에서는 Data 객체 형식으로 변경하면 자연스럽게 URL 인코딩이 적용됨
- API를 호출하는 과정은 대부분 URL 객체를 생성하는 것으로 시작함. 이 객체가 생성되어야 이를 이용하여 URLRequest 객체를 생성할 수 있기 때문이고 이 객체에는 API 호출 URL이 직접 입력되며, GET 방식으로 호출하는 경우에는 URL 객체 내부에 전달값이 직접 들어가기도 함
- 생성된 URL 객체를 이용하여 URLRequest 객체를 생성함. 이 객체에는 실제로 API를 호출할 때 필요한 요청 내용이 모두 포함되며, 앞에서 살펴본 HTTP 요청 메시지 구조를 구성하는 역할을 함. GET / POST 등의 전송 방식은 .httpMethod 속성을 통해 설정하며, 전송할 메시지 본문 내용은 .httpBody 속성을 통해 설정하면 됨.
- 헤더는 실제 내용에는 포함되지 않으면서 전송하는 콘텐츠에 대한 형식이나 특성 등 메타 정보를 제공하는 역할로 사용됨. 헤더는 URLRequest 객체에 정의된 addValue(_:forHTTPHeaderField:) 또는 setValue(_:forHTTPHeaderField:) 메소드를 사용하면 설정할 수 있음
- 헤더의 Content-Length는 전송할 메시지 본문의 길이를 알려주는 역할을 함.서버에 전송되는 데이터는 우리가 생각하는 것처럼 문자열이 덩어리 단위로 끊어져서 전송되는 것이 아니라 스트림 형식으로 계속 이어져 전달되기 때문에, 서버는 HTTP 메시지를 어디까지 끊어서 처리할지 잘 결정해야 하는데, 이때 Content-Length 헤더가 있으면 HTTP 메시지의 길이를 알 수 있어 정확하게 끊을 수 있음
- Data 객체에서 값의 길이는 count 속성을 통해 확인할 수 있으며, 이 값을 헤더에 추가할 때에는 문자열 형식으로 변경해서 집어넣어야 함
- URLRequest를 전송하는 데에는 URLSession 객체가 사용됨. URLSession.shared.dataTask(with:) 구문에 URLRequest 객체를 담으면 전송 준비가 모두 끝나고, 이어서 작성할 것은 응답 시 실행될 내용임. HTTP 통신은 비동기로 이루어지기 때문에, 우리는 응답값을 받아 처리할 내용을 클로저 형태로 미리 작성하여 인자값으로 넣어주어야 함.
- 응답 메시지 본문은 Data 타입, 응답 정보는 URLResponse 타입, 그리고 오류 정보는 Error 타입으로 정의됨
- 서버 통신 자체에 문제가 있거나 네트워크에 문제가 있어 서버에 요청 전달이 실패했다면 세 번째 매개변수에 Error 타입의 값이 대입됨
- 이 변수에 값이 들어있다면 오류가 발생하여 서버의 응답을 받아오지 못한 것으로 간주됨. 이때에는 응답 메시지 본문인 data 변수의 값이 nil이므로, 결과 처리 로직의 진행을 중지해야 함.
- 최종적으로 resume() 메소드를 호출해야만 비로소 준비된 HTTP 요청 메시지가 서버에 전달됨
- main.async() 구문은 해당 블록의 코드가 메인 쓰레드에서 비동기적으로 실행되도록 요청하는 역할을 함
- 스위프트는 비동기로 실행되는 모든 구문은 서브 쓰레드에서 실행하도록 처리하고, UI에 관련된 구문은 메인 쓰레드에서 실행하도록 아키텍처를 정리함
- URLSession 객체를 통해 비동기로 수행되는 구문은 모두 별도의 쓰레드에서 실행됨
- 멀티 쓰레딩은 연산을 병렬적으로 처리할 수 있도록 보조적인 실행 흐름을 여러 개 생성하는 방식을 의미함. 이와 대비되는 개념으로 싱글 쓰레딩이 있는데, 이는 나누어지지 않은 단일 실행 단위가 순서대로 코드를 처리하는 것을 가리킴. 특정 연산을 처리할 때 여러 개의 작은 단위로 쪼개어 계산하고 최종적으로 이를 합쳐서 완성하는 방식이 대표적인 멀티 쓰레딩 방식이며, 보조적인 실행 흐름을 만들어 각각 별도의 작업 실행을 할당하는 것도 멀티 쓰레딩에 해당함

## 8.2.3 JSON 방식으로 API 호출하기

- 딕셔너리 객체를 data(withJSONObject:options:) 메소드에 넣어 실행하면 Data 타입으로 정의된 JSON 객체가 만들어짐

# 8.3 Alamofire

## 8.3.1 Alamofire 라이브러리

- URLRequest + URLSession 객체를 래핑한 간결한 구성으로 됨
- 코코아팟(CocoaPods)은 코코아 프로젝트에 대한 의존성 패키지를 관리하는 도구 중 하나
- sudo 명령어는 현재의 계정을 루트로 변경하지 않은 채 특정 명령문만 루트 권한으로 실행할 수 있도록 도와줌

## 8.3.3 Alamofire 기본 코드 다루기

- request(“호출 URL”, method: .post, parameters: param, encoding: URLEncoding.httpBody)
- method에는 HTTPMethod 열거형 객체로 정의되어 있음
- 전달해야 할 값이 있을 경우에는 세 번째 매개변수인 parameters를 사용하면 됨. 이 변수는 키-값 형식의 딕셔너리 타입을 기반으로 함
- 전달하는 값에 특수문자나 한글 등이 포함되어 있을 경우, 서버에서 잘못 받아들이지 않도록 인코딩 과정을 거쳐야 하는데, 이때 request 메소드의 네 번째 매개변수 encoding이 사용됨
- 매개변수 encoding은 프로토콜인 ParameterEncoding 타입으로, 이 프로토콜을 구현한 열거형이나 구조체, 또는 클래스 객체를 인자값으로 입력받을 수 있음. 대표적으로 사용되는 것이 URLEncoding 구조체로, 이 구조체에는 다음과 같은 세 가지 인코딩 타입이 정적 변수로 선언되어 있음.
    - .methodDependent : 메소드에 따라 인코딩 타입이 자동으로 결정됨. 가령 GET 방식이면 .queryString, POST 방식이면 .httpBody가 적용됨
    - .queryString : GET 전송에서 사용되는 쿼리 스트링 방식으로 인코딩함
    - .httpBody : POST 전송에서 사용되는 HTTP Body 방식으로 인코딩함
- JSON 방식으로 값을 전송할 때에는 인코딩 타입으로 URLEncoding 대신 JSONEncoding을 사용해야 함
- Content-Type 헤더에 ‘application/json’ 값이 자동으로 설정됨. 이처럼 Alamofire에서 인코딩 타입을 변경하면 그에 대한 헤더는 자동으로 설정되기 때문에 직접 설정하지 않아도 됨. Content-Length 헤더 역시 입력된 파라미터 인자값과 인코딩 설정을 참고하여 Alamofire 라이브러리가 자동으로 계산되므로 우리가 설정해 줄 필요는 없음
- Alamofire는 비동기 기반으로 네트워크 응답을 처리하기 때문에, 응답 메시지를 response 메소드의 결과값으로 반환받을 수는 없음. 그에 대한 대안으로 우리는 서버로부터 응답이 도착했을 때 실행할 로직을 클로저로 미리 작성하여 위 메소드의 인자값으로 넣어주어야 함. 일종의 콜백 함수인 셈이다
- Alamofire는 서버에서 응답이 도착하면 DataResponse 타입의 객체로 처리한 다음, 이를 클로저의 매개변수에 담아 호출함. 우리는 이 객체를 활용하여 원하는 값을 추출할 수 있음.
- 인자값을 클로저 하나만을 입력받는 메소드에 트레일링 클로저 문법을 적용하면, 메소드의 괄호를 완전히 생략할 수 있음
- result.value를 그대로 출력하면 Any 타입으로 처리된 JSON 객체 본문이 그대로 출력되고, 이를 [String: Any] 타입의 Dictionary 객체로 캐스팅하면 개별 값을 추출할 수 있음. 또한 JSON 객체 본문을 그대로 출력했을 때에는 한글이 유니코드로 처리되지만, 이를 개별 값으로 추출해서 출력하면 정상적으로 처리되고 있음도 확인할 수 있음

# 8.4 실습) 메모 앱에 로그인 및 API 인증 과정 구현하기

## 8.4.2 계정 등록 기능 구현하기

- selectLibrary(src:) 함수를 반드시 tappedProfile(_:) 메소드 내부에 정의해야 하는 것은 아니지만 이 함수를 호출하는 곳이 tappedProfile(_:) 메소드 내부로 국한되므로, 이런 경우 내부 함수로 정의하는 것도 나쁘지 않은 선택임
- 화면 로드 시 마지막에 bringToSubview(toFront:)를 호출하여 인디케이터 뷰가 화면 맨 앞으로 오도록 재배치해 주어야 함

## 8.4.3 로그인 기능 구현하기

- OAuth 2.0 표준은 유효 기간이 있는 액세스 토큰과 이를 갱신할 수 있는 리프레쉬 토큰을 이용하여 직접적으로 사용자의 아이디와 비밀번호를 입력받지 않고도 사용자 연동을 처리할 수 있는 모바일 인증 표준 방식이다.
- 동기 방식은 일반적으로 실행이 끝날 때까지 다른 것을 처리하지 않고 대기하는 것을 말함. 반면 비동기 방식은 특정 기능이 실행되는 동안 대기하지 않고 다른 일을 하는 것을 의미함.
- 비동기 방식의 함수들은 일반적으로 결과값을 가지지 않으며, 처리가 끝났을 때 이어서 실행할 또 다른 함수를 입력받는 경우가 많음. 이를 콜백(Callback) 함수라고 한다.
- 비동기 방식으로 실행되는 대부분의 함수는 처리 완료 후 실행할 로직을 입력받을 수 있도록 함수나 클로저 형태의 매개변수를 정의하고 있음

## 8.4.4 인증 토큰 처리하기

- 토큰값(refresh_token, access_token)은 일종의 로그인 세션 역할을 하는 값으로, 해당 토큰을 소유한 사람이라면 별도의 자격 증명을 제시하지 않고도 관련 서비스를 사용할 수 있음. OAuth 기반 서버에서 인증이 필요한 API를 호출할 때에는 반드시 이 토큰을 함께 전송해야 함
- UserDefault는 기본적으로 데이터를 암호화하지 않을 뿐만 아니라 너무 쉽게 접근할 수 있다는 점에서 인증 토큰을 저장하기에 적당하지 않음
- 샌드박스(Sandbox)란, 외부에서 받은 파일을 바로 실행하지 않고 보호된 영역에서 실행시켜 봄으로써 잘못된 파일과 프로그램이 내부시스템 전체에 악영향을 주는 것을 미연에 방지하는 기술임.
- 키 체인을 구성하는 요소
    - 키 체인 아이템(Keychain Item) : 키 체인에 제공되는 데이터로, 키 체인은 여러 개의 키 체인 아이템을 가질 수 있음
    - 아이템 클래스(Item Class) : 저장할 데이터의 종류. ID/PW, 인증서, 인터넷 비밀번호 및 일반 비밀번호 등을 선택할 수 있으며 임의로 아이템 클래스를 추가할 수는 없음. 대표적인 아이템 클래스로는 인터넷용 아이디/패스워드를 저장할 때 사용하는 kSecClassInternetPassword, 인증서를 저장할 때 사용하는 kSecClassCertificate, 일반 비밀번호를 저장할 때 사용하는 kSecClassGenericPassword 등이 있음
    - 어트리뷰트(Attributes) : 아이템 클래스에 대한 속성. 아이템 클래스에 따라 설정할 수 있는 어트리뷰트의 종류가 달라짐
- 앱 전체에 공통으로 적용되는 kSecAttrService가 공개키 암호화에서 공개키에 해당하는 개념이라면, kSecAttrAccount는 각각의 사용자가 가지는 개인 키의 개념에 대응된다고 할 수 있음
- kSecAttrService는 서비스를 구분하기 위한 값으로, 모든 앱이 공통으로 사용하는 키 체인에서 해당 앱을 식별하기 위한 목적으로 사용됨. 보통은 앱의 번들 아이디를 넣는 경우가 많지만 강제 사항은 아니므로, 하나의 앱 내에서도 저장 용도에 따라 kSecAttrService 값을 다양하게 사용해도 됨
- 액세스 토큰, 리프레시 토큰 예
    - 액세스 토큰
        - kSecAttrAccount = accessToken
        - kSecAttrService = kr.co.rubypaper.memoapp
    - 리프레시 토큰
        - kSecAttrAccount = refreshToken
        - kSecAttrService = kr.co.rubypaper.memoapp
    - 키 체인을 다루기 위해 사용되는 메소드
        - 저장 : SecItemAdd
        - 읽기 : SecItemCopyMatching
        - 수정 : SecItemUpdate
        - 삭제 : SecItemDelete
    - 이들은 모두 C 스타일로 코딩되어 있으며, 소위 ‘키 체인 쿼리(Key Chain Query)’라고 불리는 CFDictionary 타입의 데이터 집합을 인자값으로 받아 사용함. 데이터베이스로 치자면 테이블명과 키 값, 저장할 내용 등이 모두 어우러진 SQL문에 해당함. 우리는 저장할 데이터, 아이템 클래스, 서비스명 등을 키 체인 쿼리에 정의한 다음, 목적에 맞는 함수를 호출하여 원하는 CRUD 작업을 처리하게 됨
    - 이들 메소드는 Security 프레임워크에 정의되어 있어 키 체인을 사용하려면 소스 코드 맨 위에 Security 프레임워크에 대한 반입 구문을 작성해야 함
    - 키 체인 관련 작업에서 가장 먼저 정의해야 하는 것은 키 체인 쿼리임. 키 체인 쿼리는 앞서 CFDictionary 타입이라고 설명했지만, 사용 편의상 이를 상속받은 NSDictionary 또는 NSMutableDictionary 타입을 사용하는 경우가 많음. 키 체인 쿼리에 들어가는 키들은 모두 어트리뷰트들이며, 아이템 클래스 역시 키 체인의 일부로 정의됨. Security 프레임워크에서 제공하는 어트리뷰트 키는 모두 CFString 타입으로 정의되어 있기 때문에, NSDictionary 객체에 저장하기 위해서는 어트리뷰트 키들을 NSString 또는 String 타입으로 캐스팅해야 함
    - kSecClass는 아이템 클래스를 지정하는 항목임. 쉽게 말해 ‘어떤 타입의 데이터를 저장할 거냐’하는 것이고 저장할 수 있는 아이템 클래스 타입은 다음과 같음
        - kSecClassGenericPassword
        - kSecClassInternetPassword
        - kSecClassCertificate
        - kSecClassKey
        - kSecClassIdentity
    - kSecAttrService는 저장할 값에 대한 서비스 아이디를 지정하는 어트리뷰트이고 앱 번들 아이디를 사용하는 경우가 일반적.
    - kSecAttrAccount는 저장할 값에 대한 사용자 계정을 지정하는 어트리뷰트이다.
    - kSecValueData는 실제로 저장할 값이다. Data 타입의 값을 입력받기 때문에, 실제로 값을 저장할 때에는 다음과 같이 Data 타입으로 인코딩하는 과정이 추가됨  
    `let str = “저장할 비밀번호”`  
    `let value = str.data(using: .utf8, allowLossyConversion: false)`
    - 키 체인은 새 값을 작성하면 자동으로 기존의 값을 덮어쓰는 구조가 아니므로, 키가 중복되면 새로운 값을 저장할 수 없다. 따라서 값을 저장하기 전에는 항상 기존 값을 삭제해 주어야 함
    - 저장된 값을 읽어올 때에도 가장 먼저 해야 할 것이 키 체인 쿼리를 정의하는 것이다.
    - 키 체인의 네번째 항목으로 추가된 kSecReturnData는 읽어올 데이터 타입을 결정하는 부분으로, 값으로 설정된 kCFBooleanTrue는 저장된 값을 CFData 형식으로 읽어오도록 지시하는 부분이다. 우리는 이 타입 대신 호환 가능한 AnyObject 타입을 사용하고, 일단 값을 읽어온 다음에는 바로 Data 타입으로 변환할 거다. 참고로 CFData 타입은 코어 파운데이션 프레임워크에 저장된 클래스임.
    - kSecMatchLimit은 키 체인 쿼리의 조건에 일치하는 값이 여러 개 있을 경우 어떻게 할 것인가에 대한 지정이다.
    - 저장된 값을 읽어올 때에는 SecItemCopyMatching 함수를 사용함. 이 함수는 OSStatus 타입의 처리 결과를 반환하기 때문에, 키 체인에 저장된 값은 매개변수를 이용하여 반환해야 함. 이를 위해 두 번째 매개변수를 inout 타입으로 정의함. 여기서 말하는 inout이란, 함수 내부에서 수정된 인자값을 함수 외부에서도 참조할 수 있는 것을 말함. 참조 형태이기 때문에, 인자값을 레퍼런스 형태로 넣어줌
    - AnyObject 타입으로 읽어온 값을 Data 타입으로 변환하고, 이를 다시 String 타입으로 변환하여 우리가 사용하는 형태로 만들어내면 키 체인에서 값을 읽어오는 과정이 모두 끝남
    - 실무에서는 키 체인을 쉽게 다룰 수 있도록 래핑된 클래스를 사용함
    - errSecSuccess는 성공을 의미하는 OSStatus 타입의 값임
    - 이미지를 Data 형태로 변환한 다음, 이를 JSON 형태로 전송하기 위해 base64 인코딩 과정을 거침. 많은 예제 소스들에서 이미지를 전송할 때에는 multipart/form-data라는 형식을 사용해야 하는 것으로 설명하고 있지만, 동영상이나 초고해상도 이미지 등 크기가 아주 큰 파일을 제외하면 JSON이나 URL 인코딩 형식으로 전송해도 상관없음

## 8.4.7 토큰 갱신 기능 구현하기

- 액세스 토큰은 API 호출 시 인증을 위한 용도로 사용하고, 리프레시 토큰은 액세스 토큰 만료 시 갱신을 위해 사용됨
- 토큰의 관계를 간단히 정리
    - (1) 액세스 토큰은 API 호출에 사용되며, 유효 기간이 있다(짧다)
    - (2) 리프레시 토큰은 액세스 토큰을 갱신하는 데에 사용되며, 유효 기간이 없다
    - (3) 리프레시 토큰으로 액세스 토큰을 갱신하면 새로운 액세스 토큰이 발급되지만, 리프레시 토큰은 유지된다
    - (4) 로그아웃하면 리프레시 토큰과 액세스 토큰이 모두 만료됨
    - (5) 로그인하면 기존의 리프레시 토큰과 액세스 토큰은 모두 만료되고, 새로운 토큰이 발급됨
- 터치 아이디의 API는 LocalAuthentication이라는 프레임워크를 통해 제공됨. 이 프레임워크는 우리가 지문 인식에서 흔히 보게 되는, 아이폰 버튼에 손가락 대고 스캔하기에 대한 기본 화면을 제공할 뿐만 아니라 지문 인식이 실패하거나 사용자가 이 기능을 사용하지 않을 경우 로그인 창과 같은 별도의 인증 기능으로 연결되도록 처리하는 기능도 제공함. 또한 인증이 필요한 이유를 메시지로 출력할 수 있도록 해 주기도 함
- 터치 아이디 및 로컬 인증 프레임워크를 다루기 위한 첫 번째 단계는 인증 컨텍스트를 정의하는 것. 인증에 관한 종합 정보를 관리하는 객체이다.
- 오류 코드를 처리할 변수와 터치 아이디 인증창에 들어갈 메시지를 정의.
- canEvaluatePolicy 메소드를 호출하며, 터치 아이디 인증을 사용할 수 있는지 프레임워크에 문의함
- 인증창을 실행할 때에는 evaluatePolicy 메소드가 사용됨. evaluatePolicy(_:localizedReason:reply:) 메소드는 세 개의 인자값을 필요로 함. 첫 번째 인자값은 방금 전에 사용했던 인증 정책 조건이며, 두 번째 인자값은 인증창에 표시될 인증 사유 메시지이다. 세 번째 인자값은 완료 처리 클로저로, 여기에는 성공 여부에 대한 Bool 타입의 인자값과 오류 원인이 기록될 NSError 타입의 인자값이 함께 전달됨. 실질적으로 인증 후의 처리 로직은 모두 완료 클로저 내부에 구현됨
- 인증 성공일 경우, 키 체인 등에 저장된 인증값을 이용하여 안심하고 인증을 진행하면 됨. 그러나 인증 실패일 경우, switch 구문을 통해 오류 코드별로 원인을 분석하고 이에 맞추어 대응해야 함
- 클로저는 서브 쓰레드에서 수행되므로, 로그인 화면을 띄워주는 등 UI 변경이 필요한 오류 처리의 경우에는 main 블록을 사용하여 메인 쓰레드에서 실행될 수 있도록 처리해 주는 것도 잊지 말아야 함. 혹은 이와 유사한 DispatchQueue.main 블록을 사용해도 됨
- iOS는 HTTP 호출의 성능을 높일 목적으로 응답 캐시를 사용함. 특정 HTTP 호출이 빈번하게 발생할 경우 응답 캐시에 저장된 결과를 대신 반환하여 처리함. 응답 캐시를 관리하는 객체는 URLCache로, removeAllCacheResponse() 메소드를 호출하면 공유 응답 캐시를 모두 삭제할 수 있음
- 프로그래밍에서는 특정 기능을 실행하기 위한 조건으로서의 액션 또는 이벤트를 지칭하는 용도로 트리거(Trigger)라는 용어가 사용됨
- 터치 이벤트를 대신해서 직접 액션 메소드를 호출하는 코드를 가리켜 트리거 코드라고 부름
- OperationQueue는 큐에 들어온 작업들이 순차적으로 처리되도록 해 주는 오브젝티브-C 기반의 큐이다
- 모바일 API를 터미널에서 호출할 때에는 curl 커맨드를 사용함
- OAuth 인증은 써드 파티 앱(Third-Party App, 제3자 앱)에 로그인 기능을 제공하기 위한 목적으로 구현된 것
- OAuth 인증의 핵심은 두 가지이다. 하나는 써드 파티 앱에 아이디/패스워드 정보를 제공하지 않는 것이고, 또 다른 하나는 써드 파티 앱에 수준별로 권한을 제공하는 것이다. 이 중에서 우리에게 유의미한 것은 첫 번째 핵심으로, 말하자면 OAuth는 써드 파티 앱에서 아이디 패스워드를 입력하여 직접 로그인하는 것이 아니라 퍼스트 앱을 통해 사용자가 로그인하고 그 결과에 따라 인증 토큰만 써드 파티 앱에 제공되는 방식이라고 할 수 있음. 이 때문에 원칙적으로 써드 파티 앱에서는 아이디/패스워드를 입력받을 수 없으며, 따라서 저장할 수도 없음. 대신 액세스 토큰을 갱신할 수 있는 리프레시 토큰을 이용함

# 8.5 실습) 메모 데이터 서버와 동기화하기

## 8.5.3 로그인 시 서버에 저장된 콘텐츠 내려받기

- 응답 결과에 포함된 이미지 정보는 실제 이미지를 읽을 수 있는 웹상의 경로이므로, 이를 URL 객체로 만든 다음에 Data 객체를 이용하여 이미지 데이터를 읽어오고, 이를 관리 객체 인스턴스에 대입하는 과정을 거쳐야 함
- global(qos: .background).async { } 블록은 블록 내에 작성된 코드를 백그라운드에서 실행할 수 있게 해주는 글로벌 큐이다. 포그라운드 작업을 방해하지 않고 백그라운드에서 처리해야 하는 작업이 있을 경우 해당 블록으로 감싸주면 사용자의 액션과 상관없이 수행되므로 요긴하게 사용할 수 있다.
- 사용자의 대기 시간을 줄여주기 위해 작성된 데이터 업로드 작업을 백그라운드에서 처리하는 것이 좋음. → `DispatchQueue.global(qos: .background)`
