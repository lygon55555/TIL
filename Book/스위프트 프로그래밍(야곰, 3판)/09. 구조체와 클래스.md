# 9. 구조체와 클래스

스위프트에서는 구조체와 클래스의 모습과 문법이 거의 흡사  
다만 구조체의 인스턴스는 값 타입이고 클래스의 인스턴스는 참조 타입  
스위프트의 데이터 타입과 열거형은 모두 값 타입

## 9.1 구조체

struct 키워드  
구조체를 정의한다는 것은 새로운 타입을 생성해주는 것과 마찬가지  
기본 타입 이름(Int, String, Bool 등등)처럼 대문자 카멜케이스를 사용하여 이름을 지어줌

구조체 정의를 마친 후 인스턴스를 생성하고 초기화하고자 할 때는 기본적으로 생성되는 멤버와이즈 이니셜라이저를 사용  
인스턴스가 생성되고 초기화된 후 프로퍼티 값에 접근하고 싶다면 마침표를 사용함  
구조체를 상수 let으로 선언하면 인스턴스 내부의 프로퍼티 값을 변경할 수 없음  
구조체를 변수 var로 선언하면 내부의 프로퍼티가 var로 선언된 경우에 값을 변경할 수 있음  
기본 제공되는 멤버와이즈 이니셜라이저 외에 사용자 정의 이니셜라이저도 구현 가능

## 9.2 클래스

스위프트의 클래스는 부모클래스가 없더라도 상속 없이 단독으로 정의가 가능  
클래스를 정의할 때도 대문자 카멜케이스를 사용하여 이름을 지어줌  
클래스는 상속받을 수 있기 때문에 상속 받을 때는 클래스 이름 뒤에 콜론(:)을 써주고 부모클래스 이름을 명시

인스턴스가 생성되고 초기화된 후(이니셜라이즈된 후) 프로퍼티 값에 접근하고 싶다면 마침표를 사용  
구조체와는 다르게 클래스의 인스턴스는 참조 타입이므로 클래스의 인스턴스를 상수 let으로 선언해도 내부 프로퍼티 값을 변경할 수 있음  
기본 이니셜라이저 외에 사용자가 직접 이니셜라이저를 정의할 수도 있음

클래스의 인스턴스는 참조 타입이므로 더는 참조할 필요가 없을 때 메모리에서 해제됨  
이 과정을 소멸이라고 하는데 소멸되기 직전 deinit 이라는 메서드가 호출됨  
클래스 내부에 deinit 메서드를 구현해주면 소멸되기 직전 deinit 메서드가 호출됨  
이렇게 호출되는 deinit 메서드는 디이니셜라이저(Deinitializer)라고 부름  
deinit 메서드는 클래스당 하나만 구현할 수 있음  
매개변수와 반환 값을 가질 수 없음  
deinit 메서드는 매개변수를 위한 소괄호도 적어주지 않음

```swift
class Person {
	var height: Float = 0.0
	var weight: Float = 0.0
	deinit {
		print("Person 클래스의 인스턴스가 소멸됨.")
	}
}

var yonghyun: Person? = Person()
yonghyun = nil    // Person 클래스의 인스턴스가 소멸됨.
```

deinit 메서드에는 인스턴스가 메모리에서 해제되기 직전에 처리할 코드를 넣어줌  
예를 들어 인스턴스 소멸 전에 데이터를 저장한다거나 다른 객체에 인스턴스 소멸을 알려야 할 때는 특히 deinit 메서드를 구현해야 함

## 9.3 구조체와 클래스의 차이

<구조체와 클래스의 같은 점>

- 값을 저장하기 위해 프로퍼티를 정의할 수 있음
- 기능 실행을 위해 메서드를 정의할 수 있음
- 서브스크립트 문법을 통해 구조체 또는 클래스가 갖는 값(프로퍼티)에 접근하도록 서브스크립트를 정의할 수 있음
- 초기화될 때의 상태를 지정하기 위해 이니셜라이저를 정의할 수 있음
- 초기 구현과 더불어 새로운 기능 추가를 위해 익스텐션을 통해 확장할 수 있음
- 특정 기능을 실행하기 위해 특정 프로토콜을 준수할 수 있음

<구조체와 클래스의 다른 점>

- 구조체는 상속할 수 없음
- 타입캐스팅은 클래스의 인스턴스에만 허용됨
- 디이니셜라이저는 클래스의 인스턴스에만 활용할 수 있음
- 참조 횟수 계산(Reference Counting)은 클래스의 인스턴스에만 적용됨

어떤 함수의 전달인자로 값 타입의 값을 넘긴다면 전달될 값이 복사되어 전달됨  
참조 타입이 전달인자로 전달될 때는 값을 복사하지 않고 참조(주소)가 전달됨  
참조라는 것은 C 언어, C++, Objective-C 등의 언어에서 사용되는 포인터(Pointer)와 매우 유사한 개념  
그러나 참조라는 것을 표현해주기 위하여 애스터리스크(*)를 사용하지는 않습니다  
함수의 전달인자로 넘길 때도 참조가 전달되며 다른 변수 또는 상수에 할당될 때도 마찬가지로 참조가 할당됨

값 타입의 데이터를 함수의 전달인자로 전달하면 메모리에 전달인자를 위한 인스턴스가 새로 생성됨  
생성된 새 인스턴스에는 전달하려는 값이 복사되어 들어감  
참조 타입의 데이터는 전달인자로 전달할 때 기존 인스턴스의 참조를 전달하므로 새로운 인스턴스가 아닌 기존의 인스턴스 참조를 전달함  
함수의 전달인자뿐만 아니라 새로운 변수에 할당될 때 또한 마찬가지임

클래스의 인스턴스끼리 참조가 같은지 확인할 때는 식별 연산자(Identity Operators)를 사용함

```swift
class Person {
	var height: Float = 0.0
	var weight: Float = 0.0
}

var jay: Person = Person()
let friend: Person = jay
let anotherFriend: Person = Person()

print(jay === friend)             // true
print(jay === anotherFriend)      // false
print(friend !== anotherFriend)   // true
```
<br/>

스위프트 String 타입의 정의

```swift
public struct String {
	/// An empty 'String'.
	public init()
}
```

스위프트의 다른 기본 타입(Bool, Int, Array, Dictionary, Set 등등)은 String 타입과 마찬가지로 모두 구조체로 구현되어 있음  
이는 기본 데이터 타입은 모두 값 타입이라는 뜻  
전달인자를 통해 데이터를 전달하면 모두 값이 복사되어 전달될 뿐, 함수 내부에서 아무리 전달된 값을 변경해도 기존의 변수나 상수에는 전혀 영향을 미치지 못 함  
이런 점을 더욱 확실히 하기 위해 스위프트의 전달인자는 모두 상수로 취급되어 전달되는 것일 수도 있음

## 9.4 구조체와 클래스 선택해서 사용하기

구조체 인스턴스는 항상 값 타입이고, 클래스 인스턴스는 참조 타입  
애플은 가이드라인(Swift Programming Language Guide)에서 다음 조건 중 하나 이상에 해당한다면 구조체를 사용하는 것을 권장함

- 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
- 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때
- 구조체에 저장된 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때
- 다른 타입으로부터 상속받거나 자신을 상속할 필요가 없을 때

구조체로 사용하기에 가장 적합한 예로는 좌표계가 있음

x, y 좌표 등을 표현하고 싶을 때 Int 타입으로 x, y 프로퍼티를 생성할 수 있으며, 물건의 크기를 표현하고자 할 때는 부동소수 표현인 Double 또는 Float 타입을 사용하여 width, height, depth 등으로 묶어 표현해줄 수 있음  
이런 몇 가지 상황을 제외하면 클래스로 정의하여 사용함
