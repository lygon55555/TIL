# 5. 연산자

[연산자의 분류](https://www.notion.so/d9180a3b21834d58b91995a85312d2ff)

연산자는 특정한 문자로 표현한 함수

## 5.1 연산자의 종류

스위프트에서는 부동소수점 타입의 나머지 연산까지 지원

서로 다른 자료형끼리의 연산을 실행하려면 값을 해당 타입으로 변환한 후 연산해야 함

[비교 연산자](https://www.notion.so/0cc965c658804aa491d8f7c7dd4ec9d0)

스위프트의 유일한 참조(Reference) 타입인 클래스의 인스턴스에서만 참조 비교 연산자를 사용할 수 있음

스위프트의 기본 데이터 타입은 모두 구조체로 구현되어 있기 때문에 값 타입임

그렇기 때문에 값의 비교 연산에는 ==를 사용하고 클래스의 인스턴스인 경우에만 ===를 사용함

[범위 연산자](https://www.notion.so/abf2f24fa4424427a151c6eb706d974e)

[부울 연산자](https://www.notion.so/0602cf7572a6430f93ce41377158193e)

[비트 연산자](https://www.notion.so/3d57a6c1fbd444e98f133761e811a5db)

[복합 할당 연산자](https://www.notion.so/2fc3e64ae3a54171ad01ccd1f160d427)

[오버플로 연산자](https://www.notion.so/0d4f9cc62a074de4b6cdaaf098ae332d)

[기타 연산자](https://www.notion.so/d0c01ea889f345bf8e2065a1740ac1fd)

nil 병합 연산자는 옵셔널을 사용할 때 아주 유용함

옵셔널 강제 추출 연산자 사용은 지양하는 편이 좋음

## 5.2 연산자 우선순위와 결합방향

우선순위 Precedence  
결합방향 Associativity  
연산자 우선순위 그룹 precedencegroup  
C 계열 언어와 스위프트의 연산자 우선순위나 결합방향이 완전히 같지는 않음

## 5.3 사용자 정의 연산자

prefix 전위 연산자  
infix 중위 연산자  
postfix 후위 연산자  
operator 연산자  
associativity 연산자 결합방향  
precedence 우선순위

기존에 없던 전위 연산자를 만들고 싶다면 연산자 정의를 먼저 해줌  
전위 연산자 함수를 구현할 때는 함수 func 키워드 앞에 prefix 키워드를 추가  
```swift
prefix operator **

prefix func ** (value: Int) -> Int {
	return value * value
}

let minusFive: Int = -5
let sqrtMinusFive: Int = **minusFive
print(sqrtMinusFive)  // 25
```
<br/>

스위프트 표준 라이브러리에 존재하는 전위 연산자에 기능을 추가할 때는 따로 연산자를 정의하지 않고 함수만 중복 정의하면 됨  
```swift
prefix func ! (value: String) -> Bool {
	return value.isEmpty
}

var stringValue: String = "yonghyun"
var isEmptyString: Bool = !stringValue
print(isEmptyString) // false

stringValue = ""
isEmptyString = !stringValue
print(isEmptyString) // true
```
<br/>

함수의 오버로드(중복 정의), 오버라이드(재정의)  
연산자의 재정의가 불가능하므로 기존 연산자의 우선순위나 결합방향 등을 변경할 수는 없음  
하나의 피연산자에 전위 연산과 후위 연산을 한 줄에 사용하게 되면 후위 연산을 먼저 수행

중위 연산자는 우선순위 그룹을 명시해줄 수 있음  
```swift
precedencegroup 우선순위 그룹 이름 {
	higherThan: 더 낮은 우선순위 그룹 이름
	lowerThan: 더 높은 우선순위 그룹 이름
	associativity: 결합방향(left / right / none)
	assignment: 할당방향 사용(true / false)
}
```
연산자 우선순위 그룹은 중위 연산자에서만 사용됨  
전위 연산자 및 후위 연산자는 결합방향 및 우선순위를 지정하지 않음  
하나의 피연산자에 전위 연산과 후위 연산을 한 줄에 사용하게 되면 후위 연산을 먼저 수행  
```swift
import Foundation

infix operator ** : MultiplicationPrecedence

func ** (lhs: String, rhs: String) -> Bool {
	return lhs.contains(rhs)
}

let helloYonghyun: String = "Hello yonghyun"
let yonghyun: String = "yonghyun"
let isContainsYonghyun: Bool = helloYonghyun ** yonghyun  // true
```
<br/>

클래스 및 구조체의 비교 연산자 구현

```swift
class Car {
	var modelYear: Int?
	var modelName: String?
}

struct SmartPhone {
	var company: String?
	var model: String?
}

func == (lhs: Car, rhs: Car) -> Bool {
	return lhs.modelName == rhs.modelName
}

func == (lhs: Phone, rhs: Phone) -> Bool {
	return lhs.model == rhs.model
}

let myCar = Car()
myCar.modelName = "S"
let yourCar = Car()
yourCar.modelName = "S"

var myPhone = Phone()
myPhone.model = "5S"
var yourPhone = Phone()
yourPhone.model = "X"

print(myCar == yourCar)  // true
print(myPhone == yourPhone) // false
```
<br/>

특정 타입에 국한된 연산자 함수라면 그 타입 내부에 구현되는 것이 읽고 이해하기에 더 쉬움  
타입 내부에 타입 메서드로 구현할 수도 있음  
```swift
class Car {
	var modelYear: Int?
	var modelName: String?
	
	static func == (lhs: Car, rhs: Car) -> Bool {
		return lhs.modelName == rhs.modelName
	}
}

struct Phone {
	var company: String?
	var model: String?
	
	static func == (lhs: Phone, rhs: Phone) -> Bool {
		return lhs.model == rhs.model
	}
}
```

타입 메서드로 구현된 사용자 정의 연산자는 각 타입의 익스텐션으로 구현해도 됨
