# 4부 - 컴포넌트 원칙

- SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.

## <12장 – 컴포넌트>

- 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.  
컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체다.  
인터프리터형 언어의 경우는 소스 파일의 결합체다.  
모든 언어에서 컴포넌트는 배포할 수 있는 단위 입자다.
- 여러 컴포넌트들이 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다.  
컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사

- 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다.
- 프로그래머가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.
- 라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다.
- 메모리가 너무 작아서 소스 코드 전체를 메모리에 상주시킬 수가 없었다.
- 결국 컴파일러는 느린 장치를 이용해서 소스 코드를 여러 차례 읽어야만 했다.
- 컴파일 시간을 단축시키기 위해 프로그래머는 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리했다.
- 함수 라이브러리를 개별적으로 컴파일하고, 컴파일된 바이너리를 메모리의 특정 위치에 로드했다.
- 프로그래머가 함수 라이브러리에 더 많은 함수를 추가하면 이 역시 할당된 메모리 주소를 넘어서게 되고, 결국 추가 공간을 할당해야 한다.

### 재배치성

- 위 문제의 해결책은 재배치가 가능한 바이너리(relocatable binary)였다.
- 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것이었다.
- 로더는 여러 개의 바이너리를 입력받은 후, 단순히 하나씩 차례로 메모리로 로드하면서 재배치하는 작업을 처리했다.
- 이를 통해 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었다.
- 이렇게 링킹 로더(linking loader)가 탄생했다.

### 링커

- 로그와 링크가 두 단계로 분리되었다.
- 프로그래머가 느린 부분, 즉 링크 과정을 맡았는데, 링커(linker)라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었다.
- 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라졌다.
- 비록 느린 링커를 사용해서 실행 파일을 만들었지만, 한번 만들어둔 실행 파일은 언제라도 빠르게 로드할 수 있게 되었다.
- 컴포넌트 플러그인 아키텍처(component plugin architecture)가 탄생했다.

## <13장 컴포넌트 응집도>

### REP: 재사용/릴리스 등가 원칙(Reuse/Release Equivalence Principle)

- 재사용 단위는 릴리스 단위와 같다.
- 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.
- 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다는 사실은 컴포넌트 제작자 입장이나 사용자 입장에서도 이치에 맞는 얘기다.

### CCP: 공통 폐쇄 원칙(Common Closure Principle)

- 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
- 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 것이다.
- SRP에서 단일 클래스(class)는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, 공통 폐쇄 원칙(CCP)에서도 마찬가지로 단일 컴포넌트(component)는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.
- 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.
- CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한 곳으로 묶을 것을 권한다.
- 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.

### SRP와의 유사성

- 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.

### CRP: 공통 재사용 원칙(Common Reuse Principle)

- 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
- CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.
- 간단한 사례로 컨테이너(container) 클래스와 해당 클래스의 이터레이터(iterator) 클래스를 들 수 있다.  
이들 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용된다.  
따라서 이들 클래스는 반드시 동일한 컴포넌트에 위치해야 한다.
- CRP는 동일한 컴포넌트로 묶어서는 안 되는 클래스가 무엇인지도 말해준다.
- 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.  
한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다.  
즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다.
- CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다.  
CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.

### ISP와의 관계

- CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다.  
ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언한다.  
CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.
- 필요하지 않은 것에 의존하지 말라.

### 컴포넌트 응집도에 대한 균형 다이어그램

- REP와 CCP는 포함(inclusive) 원칙이다.  
즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.
- CRP는 배제(exclusive) 원칙이며, 컴포넌트를 더욱 작게 만든다.
- 이 원칙들이 균형을 이루는 방법을 찾아야 한다.
- 균형(tension) 다이어그램 - 책 113쪽 그림 1 참고
- 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다.

### 결론

- 시간이 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.

## <14장 – 컴포넌트 결합>

### ADP: 의존성 비순환 원칙

- 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.
- 누군가 나보다 더 늦게까지 일하면서 내가 의존하고 있던 무언가를 수정해서 전 날 작동하던 코드가 다음 날에 작동을 안 하는 현상 → 숙취 증후군(the morning after syndrome)
- ‘숙취 증후군’은 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다.
- 해결책 : 주 단위 빌드, 의존성 비순환 원칙

### 주 단위 빌드(Weekly Build)

- 모든 개발자는 일주일의 첫 4일 동안은 서로를 신경 쓰지 않고 개발을 하고 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
- 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.

### 순환 의존성 제거하기

- 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
- 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.  
담당 개발자는 이 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다.  
그런 다음 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다.  
나머지 개발자는 릴리스된 버전을 사용한다.
- 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.  
의존성 구조에 순환이 있어서는 안 된다.
- 책 119쪽 그림 1 참고  
어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없는 사실이다.  
이 구조에는 순환이 없다.  
즉, 이 구조는 비순환 방향 그래프(Directed Acyclic Graph, DAG)다.
- 시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.  
Entities → Database, Interactors, Presenters, View, Controllers, Authorizer → Main

### 순환이 컴포넌트 의존성 그래프에 미치는 영향

- 책 120쪽 그림 2 참고
- 순환 의존성(dependency cycle) 발생
- 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다.
- 단위 테스트를 하고 릴리스를 하는 일도 굉장히 어려워지며 에러도 쉽게 발생한다.
- 게다가 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.

### 순환 끊기

- 컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라도 가능하다. → 이를 위한 주요 메커니즘 2가지
- (1) 의존성 역전 원칙(DIP)을 적용한다. 책 122쪽 그림 3 참고
    - User가 필요로 하는 메서드를 제공하는 “인터페이스”를 생성한다.
    - 이 인터페이스는 Entities에 위치시키고, Authorizer에서는 이 인터페이스를 상속받는다.
    - 이렇게 하면 Entities와 Authorizer 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.
- (2) Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다. 
그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

### 흐트러짐(Jitters)

- 순환이 발생하면 어떤 식으로든 끊어야 한다.
- 이 말은 때론 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수도 있음을 의미한다.

### 하향식(top-down) 설계

- 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성(buildability)과 유지보수성(maintainability)을 보여주는 지도(map)와 같다.
- 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.
- 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.
- 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.

### SDP: 안정된 의존성 원칙

- 안정성의 방향으로(더 안정된 쪽에) 의존하라.
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
- 안정된 의존성 원칙(Stable Dependencies Principle, SDP)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

### 안정성(Stability)

- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.
- 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.
- 책 126쪽 그림 5 참고
    - 세 컴포넌트가 X에 의존한다. → X는 세 컴포넌트를 책임진다(responsible)
    - X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다. → X는 독립적이다(independent)
- 책 126쪽 그림 6 참고
    - 어떤 컴포넌트도 Y에 의존하지 않는다. → Y는 책임성이 없다.
    - Y는 세 개의 컴포넌트에 의존한다. → Y는 의존적이다.

### 안정성 지표

- 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 방법이 있다. → 컴포넌트가 위치상(positional) 어느 정도의 안정성을 가지는지 계산할 수 있다.
    - *Fan-in* : 안으로 들어오는 의존성 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타낸다.
    - *Fan-out* : 바깥으로 나가는 의존성. 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타낸다.
    - *I*(불안정성) : *I = Fan-out ÷ (Fan-in + Fan-out)*
        - *I = 0*이면 최고로 안정된 컴포넌트라는 뜻
            - 해당 컴포넌트에 의존하는 다른 컴포넌트가 있다. (*Fan-in > 0*)
            - 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다. (*Fan-out = 0*)
        - *I = 1*이면 최고로 불안정한 컴포넌트라는 뜻
            - 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않는다. (*Fan-in = 0*)
            - 해당 컴포넌트는 다른 컴포넌트에 의존한다. (*Fan-out > 0*)
        - 소스 파일이 클래스당 하나가 되도록 소스 코드를 구조화하면, *I* 지표는 쉽게 계산할 수 있다.
        - SDP에서 컴포넌트의 *I* 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 *I*보다 커야 한다고 말한다. 즉, 의존성 방향으로 갈수록 *I* 지표 값이 감소해야 한다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

- 모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. → 바람직한 상황이 아님
- 사실 우리가 컴포넌트 구조를 설계할 때 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상태다.
- 세 컴포넌트로 구성된 시스템이 가질 수 있는 이상적인 구조 → 책 129쪽 그림 8 참고
- 다이어그램에서 불안정한 컴포넌트를 관례적으로 위쪽에 두는데, 이 관례를 따르면 상당히 유용하다.
- SDP가 어떻게 위배되는지에 대한 예시 → 책 129쪽 그림 9 참고
    - DIP를 도입하면 문제를 해결할 수 있다.
    - 인터페이스를 만들고 별도의 컴포넌트에 넣는다. (추상 컴포넌트)  
    이 컴포넌트를 의존하도록 강제한다.

### 추상 컴포넌트

- 오로지 인터페이스만을 포함하는 컴포넌트
- 상당히 안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.
- 루비나 파이썬 같은 동적 타입 언어를 사용할 때는 이러한 추상 컴포넌트가 전혀 존재하지 않을 뿐만 아니라, 추상 컴포넌트로 향하는 의존성 같은 것도 전혀 없다.

### SAP: 안정된 추상화 원칙

- 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

### 고수준 정책을 어디에 위치시켜야 하는가?

- 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(*I=0*)에 위치해야 한다.
- 불안정한 컴포넌트(*I=1*)는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다.
- 컴포넌트가 최고로 안정된 상태이면서도(*I=0*) 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?  
→ 해답은 개방 폐쇄 원칙(OCP)에서 찾을 수 있다.
- OCP에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있을 뿐만 아니라 바람직한 방식이라고 말한다.  
→ 추상(abstract) 클래스

### 안정된 추상화 원칙

- 안정된 추상화 원칙(Stable Abstractions Principle, SAP)은 안정성(stability)과 추상화 정도(abstractness) 사이의 관계를 정의한다.
- 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다.
- 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.
- 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
- SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며,  
SAP에서는 안정성이 결국 추상화를 의미한다고 말한다.  
→ 따라서 의존성은 추상화의 방향으로 향하게 된다.

### 추상화 정도 측정하기

- *A* 지표는 컴포넌트의 추상화 정도를 측정한 값이다.
    - *Nc*: 컴포넌트의 클래스 개수
    - *Na*: 컴포넌트의 추상 클래스와 인터페이스의 개수
    - *A*: 추상화 정도. *A=Na÷Nc* A가 0이면 컴포넌트에는 추상 클래스가 하나도 없다 A가 1이면 컴포넌트는 오로지 추상 클래스만을 포함한다.
- 주계열
    - 안정성(*I*)과 추상화 정도(*A*) 사이의 관계를 정의  
    → 수직축에는 *A*를, 수평축에는 *I*를 나타내는 그래프를 그린다.
        - 최고로 안정적이며 추상화된 컴포넌트는 좌측 상단인 (0, 1)에 위치
        - 최고로 불안정하며 구체화된 컴포넌트는 우측 하단딘 (1, 0)에 위치
    - *A/I* 그래프 상에서 컴포넌트가 위치할 수 있는 합리적인 지점을 정의하는 점의 궤적이 있으리라고 가정해볼 수 있다.  
    → 이 궤적은 컴포넌트가 절대로 위치해서는 안 되는 영역, 다시 말해 배제할 구역(Zone of Exclusion)을 찾는 방식으로 추론할 수 있다.

### 고통의 구역

- 추상적이면 확장할 수 없고, 안정적이면 변경하기 어렵다.
- 제대로 설계된 컴포넌트라면 (0, 0) 근처에는 위치하지도 않을 거라고 보는 게 일반적이다.
- (0, 0) 주변 영역은 배제해야 할 구역이며, 고통의 구역(Zone of Pain)이라고 부른다.
- 데이터베이스 스키마, String 컴포넌트 등은 (0, 0) 근처에 위치한다.
- 변동성이 없는 컴포넌트는 (0, 0) 구역에 위치했더라도 해롭지 않다. 고통의 구역에서 문제가 되는 경우는 변동성이 있는 소프트웨어 컴포넌트다.

### 쓸모없는 구역

- (1, 1) 주변에 위치한 컴포넌트는 최고로 추상적이지만, 누구도 그 컴포넌트에 의존하지 않는다. → 이러한 컴포넌트는 쓸모가 없다.  
→ 이 영역은 쓸모없는 구역(Zone of Uselessness)라고 부른다.

### 배제 구역 벗어나기

- 변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 한 멀리 떨어뜨려야 한다.  
각 배제 구역으로부터 최대한 멀리 떨어진 점의 궤적은 (1, 0)과 (0, 1)을 잇는 선분이다.  
→ 이 선분을 주계열(Main Sequence)라고 부른다.
- 주계열에 위치한 컴포넌트는 자신의 안정성에 비해 ‘너무 추상적’이지도 않고, 추상화 정도에 비해 ‘너무 불안정’하지도 않다.
- 컴포넌트가 위치할 수 있는 가장 바람직한 지점은 주계열의 두 종점이다.
- 대규모 시스템에서 소수의 일부 컴포넌트는 완벽히 추상적이거나 완전하게 안정적일 수 없다.  
이들 컴포넌트는 주계열 바로 위에 또는 가깝게 위치할 때 가장 이상적이다.

### 주계열과의 거리

- 컴포넌트가 주계열 바로 위에, 또는 가까이 있는 것이 바람직하다면, 이 같은 이상적인 상태로부터 컴포넌트가 얼마나 멀리 떨어져 있는지 측정하는 지표를 만들어 볼 수 있다.
- $ D^4 $: 거리. *D*=|*A*+*I*1|.  
*D*가 0이면 컴포넌트가 주계열 바로 위에 위치한다는 뜻 *D*가 1이면 주계열로부터 가장 멀리 위치한다는 뜻
- 이 지표를 계산하면 컴포넌트가 주계열에 대체로 일치하도록 설계되었는지를 분석할 수 있다.  
→ *D* 값이 0에 가깝지 않은 컴포넌트가 있다면 해당 컴포넌트는 재컴토한 후 재구성할 수 있다.
- 설계를 통계적으로 분석하는 일 또한 가능해진다.
    - 설계에 포함된 모든 컴포넌트에 대해 *D* 지표의 평균과 분산을 구한다.
    - 주계열에 일치하도록 설계되었다면 평균과 분산은 0에 가까워진다.
    - 분산은 ‘관리 한계(control limit)’를 결정하기 위한 목적으로 사용할 수 있는데, 분산을 통해 다른 컴포넌트에 비해 ‘극히 예외적인’ 컴포넌트를 식별할 수 있기 대문이다.
- *D* 지표를 활용하는 또 다른 방법으로, 각 컴포넌트의 *D* 값을 시간에 따라 그려볼 수 있다.

### 결론

- 의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 ‘훌륭한’ 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.
- 하지만 지표는 신이 아니다.  
지표는 그저 임의로 결정된 표준을 기초로 한 측정값에 지나지 않는다.
- 이들 지표로부터 무언가 유용한 것을 찾을 수 있기를 바란다.
