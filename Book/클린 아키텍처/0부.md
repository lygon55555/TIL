# 0부

# <옮긴이(송준이)의 글>

- SA(소프트웨어 아키텍트)
- 소프트웨어 시스템이란 무엇인지를 우리는 제대로 이해하고 있을까?  
소프트웨어 시스템을 통해서 우리가 얻고자 하는 것은 무엇일까?
- 잘 설계한 소프트웨어 아키텍처는 소프트웨어 시스템을 만들 때 왜 중요할까?  
중요하다면 어떻게 해야 소프트웨어 아키텍처를 잘 만들 수 있을까?
- 지난 반세기 동안 하드웨어는 더 작아지고 빨라졌지만, 소프트웨어를 구성하는 것들은 조금도 바뀌지 않았다.  
그렇기에 좋은 소프트웨어 아키텍처를 만드는 원칙은 보편적이며 시간이 지나더라도 변함이 없다.

# <케블린 헤니(Kevlin Henney)의 추천사>

- 아키텍처라는 렌즈를 통해 소프트웨어를 살펴보면, 알 수 있는 것만큼이나 숨겨진 것도 있게 마련이다.
- 아키텍처의 매력은 그 구조에 있다.  
구조란 패러다임을 지배하고 소프트웨어 개발의 논의를 지배하는 무언가로서, 컴포넌트, 클래스, 함수, 모듈, 계층, 서비스(마이크로서비스든 아니든)가 그 예다.
- 소프트웨어는 무엇으로 구성되는가?  
소프트웨어는 소프트웨어로 구성된다.  
큰 소프트웨어 구조물은 작은 소프트웨어 컴포넌트로 만들어지며, 이 컴포넌트는 더 작은 컴포넌트로 만들어지고, 계속 이런 식이다.
- 우리가 이야기하는 소프트웨어 아키텍처에서의 소프트웨어는 본질적으로 재귀적이고 프랙털 구조로 되어 있으며, 코드를 통해 아로새겨지고 스케치된다.  
모든 것이 세부사항이다.
- 소프트웨어 아키텍처는 특정한 모습을 지니지 않는다.  
어떤 모습으로 시각화할지는 선택일 뿐, 정해져 있지 않다.
- 소프트웨어는 마치 꿈을 구성하는 재료와 같지만, 실행되는 곳은 물리적인 세계다.
- 좋은 아키텍처는 사용자, 개발자, 소유자의 요구를 특정 시점에도 반드시 충족시켜줄 뿐만 아니라, 시간이 흐르더라도 계속 충족시켜 준다.
- 과거를 이해하는 일은 그 자체로도 충분히 어렵다.  
현재를 파악하는 수준은 아무리 해도 불완전하다.  
미래를 예측하는 일은 명확하지 않다.
- 추측성 일반화(speculative generality) : 마틴 파울러의 <리팩토링>에서 이야기하는 코드의 나쁜 냄새 중 하나. 현재가 아닌 미래의 확장성을 기대하여 지나치게 일반화하는 경우를 가리킨다.
- 우리가 가장 관심 있는 길은 바로 가장 깔끔한(clean) 길이다.  
이 길은 소프트웨어가 지닌 ‘부드러움(softness)’을 인지하고, 이 부드러움을 시스템에서 최우선으로 보존하는 것을 목표로 한다.
- 아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 더 가까움을 이해해야 좋은 아키텍처가 만들어진다.

# <서문>

- 아키텍처 규칙은 동일하다!
- 다양한 시스템이 왜 비슷한 아키텍처 규칙을 공유하는 걸까?  
소프트웨어 아키텍처의 규칙은 다른 모든 변수에 독립적이라는 결론을 내렸다.
- 똑같이 지난 반세기 동안 하드웨어가 얼마나 변화했나를 생각해 보면 이 사실은 훨씬 더 놀랍게 느껴진다.
- 현재의 소프트웨어는 과거와 동일한 것들로 구성된다.  
여전히 if문, 할당문, while 루프로 구성된다.
- 코드는 여전히 순차(sequence), 분기(selection), 반복(iteration)의 집합체일 뿐이다.
- 이처럼 코드가 변하지 않았다는 사실이 시스템의 종류와 관계없이 소프트웨어 아키텍처의 규칙이 일관된 이유다.  
소프트웨어 아키텍처의 규칙이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이다.
- 규칙은 바뀌지 않았다.  
그 모든 새로운 언어, 그 모든 새로운 프레임워크, 그 모든 패러다임에도 불구하고, 이 규칙은 앨런 튜링(Alan Turing)이 최초로 기계어 코드를 작성한 1946년에서 달라지지 않았다.
- 하지만 바뀐 게 딱 하나 있다. 그 시절의 우리는 이 규칙이 무엇인지를 알지 못했다. 결과적으로 우리는 이 규칙을 어겼고, 또 어겼고, 계속해서 어겼다.  
이제 우리는 반세기에 걸친 경험을 바탕으로 이 규칙이 무엇인지 깨닫게 되었다.
- 그리고 이 책은 바로 이 규칙, 세월이 흘러도 변치 않는 그 규칙에 관한 것이다.
