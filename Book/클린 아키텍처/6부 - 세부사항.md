# 6부 - 세부사항

# <30장 – 데이터베이스는 세부사항이다>

- 아키텍처 관점에서 볼 때 데이터베이스는 엔티티가 아니다.
- 애플리케이션 내부 데이터의 구조는 시스템 아키텍처에서 대단히 중요하다. 하지만 데이터베이스는 데이터 모델이 아니다. 데이터베이스는 일개 소프트웨어일 뿐이다. 데이터베이스는 데이터에 접근할 방법을 제공하는 유틸리티이다. 아키텍처 관점에서 보면 이러한 유틸리티는 저수준의 세부사항(메커니즘)일 뿐이라서 아키텍처와는 관련이 없다.

### 관계형 데이터베이스

- 관계형 데이터베이스는 세부사항이다.
- 많은 데이터 접근 프레임워크가 테이블과 행이 객체 형태로 시스템 여기 저기에서 돌아다니게 허용하는데, 아키텍처적으로 잘못된 설계이다. 이렇게 하면 유스케이스, 업무 규칙, 심지어는 UI 조차도 관계형 데이터 구조에 결합되어 버린다.

### 데이터베이스 시스템은 왜 이렇게 널리 사용되는가?

- 디스크 때문에 피해갈 수 없는 시간 지연이라는 짐을 완화하기 위해 색인, 캐시, 쿼리 계획 최적화가 필요해졌다.  
데이터 접근 및 관리 시스템이 필요했다.
- 파일 시스템은 문서(document) 기반이다.  
일련의 문서를 이름을 기준으로 저장하거나 조회할 때는 잘 동작하지만, 내용을 기준으로 검색할 때는 그리 크게 도움되지 않는다.
- 데이터베이스 시스템은 내용 기반이다. 데이터베이스 시스템은 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법을 제공한다. 레코드가 서로 공유하는 일부 내용에 기반해서 다수의 레코드를 연관 짓는 데 매우 탁월하다.
- 데이터를 빠르게 조작할 수 있도록 결국에는 관련 있는 데이터를 RAM으로 가져온다.

### 디스크가 없다면 어떻게 될까?

- 이 데이터들을 연결 리스트, 트리, 해시 테이블, 스택, 큐 혹은 여타 무수히 많은 데이터 구조로 체계화할 것이며, 데이터에 접근할 때는 포인터나 참조를 사용할 것이다.

### 세부사항

- 데이터베이스는 세부사항이다.  
데이터베이스는 그저 메커니즘에 불과하며, 디스크 표면과 RAM 사이에서 데이터를 이리저리 옮길 때 사용할 뿐이다.
- 아키텍처 관점에서 본다면 회전식 자기 디스크에 데이터가 있기만 한다면, 데이터가 어떤 형태인지는 절대로 신경 써서는 안 된다.

### 하지만 성능은?

- 데이터 저장소의 측면에서 성능은 완전히 캡슐화하여 업무 규칙과는 분리할 수 있는 관심사다.  
이는 저수준의 관심사다.  
성능은 시스템의 전반적인 아키텍처와는 아무런 관련이 없다.

### 결론

- 데이터를 회전식 자기 디스크 표면에서 이리저리 옮길 뿐인 기술과 시스템은 아키텍처적으로 중요치 않다.  
데이터는 중요하다.  
데이터베이스는 세부사항이다.

# <31장 – 웹은 세부사항이다>

### 요약

- GUI는 세부사항이다. 웹은 GUI다. 따라서 웹은 세부사항이다. 그리고 아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다.

# <32장 – 프레임워크는 세부사항이다>

- 프레임워크는 아키텍처가 될 수 없다.

### 해결책

- 프레임워크를 사용할 수는 있다. 다만 프레임워크와 결합해서는 안 된다.  
프레임워크는 아키텍처의 바깥쪽 원에 속하는 세부사항으로 취급하라.
- 프락시(proxy)를 만들고, 업무 규칙에 플러그인할 수 있는 컴포넌트에 이들 프락시를 위치시켜라.
- 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합하고, 의존성 규칙을 준수하라.

# <33장 – 사례 연구: 비디오 판매>

### 유스케이스 분석

- 추상 유스케이스는 범용적인 정책을 담고 있으며, 다른 유스케이스에서 이를 더 구체화한다.

### 컴포넌트 아키텍처

- 각 컴포넌트를 독립적으로 컴파일하고 빌드할 수 있는 환경을 구성하면, 후에 시스템이 변경되는 양상에 맞춰 시스템 배포 방식을 조정할 수 있다.

### 의존성 관리

- 모든 의존성은 경계선을 한 방향으로만 가로지르는데, 항상 더 높은 수준의 정책을 포함하는 컴포넌트를 향한다.
- 사용 관계(열린 화살표)는 제어흐름과 같은 방향을 가리키며, 상속 관계(닫힌 화살표)는 제어흐름과는 반대 방향을 가리킴에 주목하자. 이는 개방 폐쇄 원칙을 적용했음을 보여준다.  
의존성이 올바른 방향으로 흐르며, 따라서 저수준의 세부사항에서 발생한 변경이 상위로 파급되어서 상위 수준의 정책에 영향을 미치지는 않음을 보장할 수 있다.

# <34장 – 빠져 있는 장>

### 계층 기반 패키지

- 전통적인 수평 계층형 아키텍처  
기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할한다.
- 코드는 계층이라는 얇은 수평 조각으로 나뉘며, 각 계층은 유사한 종류의 것들을 묶는 도구로 사용된다.

### 기능 기반 패키지

- 서로 연관된 기능, 도메인 개념, 또는 (도메인 주도 설계 용어를 사용한다면) Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다.

### 포트와 어댑터

- ‘내부’ 영역은 도메인 개념을 모두 포함하는 반면, ‘외부’ 영역은 외부 세계(예를 들면 UI, 데이터베이스, 서드파티 통합)와의 상호작용을 포함한다. 여기서 주요 규칙은 바로 ‘외부’가 ‘내부’에 의존하며, 절대 그 반대로는 안 된다는 점이다.

### 컴포넌트 기반 패키지

- “컴포넌트는 멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음으로, 애플리케이션과 같은 실행 환경 내부에 존재한다.”
- 소프트웨어 시스템의 정적 구조를 컨테이너, 컴포넌트, 클래스(또는 코드)의 측면에서 계층적으로 생각하는 간단한 방법이다. 이 방법론에서 소프트웨어 시스템은 하나 이상의 컨테이너(예를 들어 웹 애플리케이션, 모바일 앱, 독립형 애플리케이션, 데이터베이스, 파일 시스템 등)로 구성되며, 각 컨테이너는 하나 이상의 컴포넌트를 포함한다. 또한 각 컴포넌트는 하나 이상의 클래스(또는 코드)로 구현된다. 이때 각 컴포넌트가 개별 jar 파일로 분리될지 여부는 직교적인 관심사(orthogonal concern)다.
- 한 요소에서 발생한 변경이 다른 변경에 영향을 미치지 않을 때, 두 요소는 서로 ‘직교’ 관계라고 말한다. ‘독립적인’, 또는 ‘관련이 없는’과 동일한 의미다.
- 컴포넌트 기반 패키지 접근법의 주된 이점은 주문과 관련된 무언가를 코딩해야 할 때 오직 한 곳, 즉 OrdersComponent만 둘러보면 된다는 점이다.

### 구현 세부사항엔 항상 문제가 있다

- 모든 타입에서 public 지시자를 사용한다는 건 사용하는 프로그래밍 언어가 제공하는 캡슐화 관련 이점을 활용하지 않겠다는 뜻이다.

### 조직화 캡슐화

- 만약 자바 애플리케이션에서 모든 타입을 public으로 지정한다면, 패키지는 단순히 조직화를 위한 메커니즘(폴더와 같이 무언가를 묶는 방식)으로 전략하여 캡슐화를 위한 메커니즘이 될 수 없다.
- 모든 타입을 public으로 선언한다면, 우리가 실제로 갖게 되는 것은 수평적 계층형 아키텍처를 표현하는 네 가지 방식에 지나지 않는다.
- 자바에서 접근 지시자를 적절하게 사용하면, 타입을 패키지로 배치하는 방식에 따라서 각 타입에 접근할 수 있는 정도(또는 접근 불가능한 정도)가 실제로 크게 달라질 수 있다.

### 결론: 빠져 있는 조언

- 최적의 설계를 꾀했더라도, 구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수도 있다.
