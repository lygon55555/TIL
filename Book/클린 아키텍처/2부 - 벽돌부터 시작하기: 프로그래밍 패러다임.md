# 2부 - 벽돌부터 시작하기: 프로그래밍 패러다임

- 소프트웨어 아키텍처는 코드(code)로부터 시작한다.
- 프로그래밍 패러다임(paradigm)
- 패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.  
패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.  
현재까지 이러한 패러다임에는 세 가지 종류가 있다.

## <3장 – 패러다임 개요>

- 구조적 프로그래밍(structured programming)  
객체지향 프로그래밍(object-oriented programming)  
함수형 프로그래밍(functional programming)

### 구조적 프로그래밍

- 에츠허르 비버 데이크스트라(Edsger Wybe Dijkstra)는 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실을 제시했다.
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

### 객체 지향 프로그래밍

- 올레 요한 달(Ole Johan Dahl)과 크리스텐 니가드(Kristen Nygaard)는 알골(ALGOL) 언어의 함수 호출 스택 프레임(stack frame)을 힙(heap)으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다.
- 바로 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 그리고 중첩 함수는 메서드가 되었다.
- 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 되었다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

### 함수형 프로그래밍

- 알론조 처치(Alonzo Church)는 람다(lambda) 계산법을 발명
- 람다 계산법의 기초가 되는 개념은 불변성(immutability)으로, 심볼(symbol)의 값이 변경되지 않는다는 개념이다.
- 이는 함수형 언어에는 할당문이 전혀 없다는 뜻이기도 하다.
- 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

### 생각할 거리

- 각 패러다임은 프로그래머에게서 권한을 박탈한다.
- 어느 패러다임도 새로운 권한을 부여하지 않는다.
- 각 패러다임은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과한다.
- 즉, 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
- 세 가지 패러다임 각각은 우리에게서 goto문, 함수 포인터, 할당문을 앗아간다.
- 프로그래밍 패러다임은 앞으로도 딱 세 가지밖에 없을 것이다.

## <4장 – 구조적 프로그래밍>

### 증명(proof)

- 유클리드 계층구조
    - 공리(axiom)는 증명 없이 참으로 받아들이는 명제.
    - 정리(theorem)는 증명이라는 과정을 통해 참이라는 것이 밝혀진 명제이고 이러한 이러한 정리를 증명하는 데 필요한 정리를 보조정리(lemma)로 부르며, 정리를 통해 자연스럽게 도출되는 정리를 따름정리(corollary)라고 부른다.
    - 데이크스트라는 프로그램을 증명하는 이러한 계층구조를 만들고자 했다.
- 데이크스트라는 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.
- 만약 모듈을 분해할 수 없다면, 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없게 된다.
- 뵘(Böhm)과 야코피니(Jacopini)는 모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration)이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.
- 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다.
- 구조적 프로그래밍은 이렇게 탄생했다.
- 데이크스트라는 단순한 열거법을 이용해 순차 구문(sequential statement)이 올바름을 입증할 수 있다는 사실을 보여주었다.
- 분기(selection)의 경우 열거법을 재적용하는 방식으로 처리했다.
- 반복(iteration)이 올바름을 증명하기 위해 귀납법(induction)을 사용했다.

### 기능적 분해

- 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.
- 그리고 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 수 있다.
- 게다가 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.
- 구조적 분석(structured analysis)이나 구조적 설계(structured design)와 같은 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 잇는 아주 작은 기능들로 세분화할 수 있다.

### 과학이 구출하다

- 과학적 방법은 반증은 가능하지만 증명은 불가능하다.
- 수학은 증명 가능한 서술이 참임을 입증하는 원리라고 볼 수 있다.
- 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있다.

### 테스트

- 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.
- 소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 소프트웨어 개발은 수학적인 시도가 아니라는 사실이다.
- 오히려 소프트웨어는 과학과 같다.
- 최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.
- 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.
- 그러고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.
- 이처럼 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.

### 결론

- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다.
- 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.

## <5장 – 객체 지향 프로그래밍>

- 좋은 아키텍처를 만드는 일은 객체 지향(Object-Oriented, OO) 설계 원칙을 이해하고 응용하는 데서 출발한다.
- 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism)

### 캡슐화?

- OO를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공하기 때문이다.
- 그리고 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.
- 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.
- 이 개념들이 실제 OO 언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다.
- OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 것이라는 믿음을 기반으로 한다.

### 상속?

- 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.
- OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수는 있다.

### 다형성?

- 44쪽 코드 참고
- getchar() 함수는 STDIN에서 문자를 읽는다.
- putchar() 함수는 STDOUT으로 문자를 쓴다.
- 이러한 함수는 다형적(polymorphic)이다.
- 즉, 행위가 STDIN과 STDOUT의 타입에 의존한다.
- 유닉스 운영체제의 경우 모든 입출력 장치 드라이버가 다섯 가지 표준 함수를 제공할 것을 요구한다.
- 열기(open), 닫기(close), 읽기(read), 쓰기(write), 탐색(seek)이 바로 이 표준 함수들이다.
- 함수를 가리키는 포인터를 응용한 것이 다형성이다.
- OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.
- 함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식에는 문제가 있는데, 함수 포인터는 위험하다는 사실이다.
- 이러한 기법은 프로그래머가 특정 관례를 수동으로 따르는 방식이다.
- 즉, 이들 포인터를 초기화하는 관례를 준수해야 한다는 사실을 기억해야 한다
- 그리고 이들 포인터를 통해 모든 함수를 호출하는 관례를 지켜야 한다는 점도 기억해야 한다.
- 만약 프로그래머가 관례를 지켜야 한다는 사실을 망각하게 되면 버그가 발생하고, 이러한 버그는 찾아내고 없애기가 지독히도 힘들다.
- OO 언어는 이러한 관례를 없애주며, 따라서 실수할 위험이 없다.
- OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.

### 다형성이 가진 힘

- 만약 천공카드냐 테이프냐에 관계없이 동일한 프로그램을 사용할 수 있다면 매우 유용할 것이다.
- 플로그인 아키텍처(plugin architecture)는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.
- OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

### 의존성 역전(dependency inversion)

- OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
- 소스 코드 의존성은 소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.
- 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다. → 배포 독립성(independent deployability)
- 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다. → 개발 독립성(independent developability)

### 결론

- OO란 무엇인가?
- 소프트웨어 아키텍트 관점에서 정답은 명백하다.
- OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
- OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
- 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## <6장 – 함수형 프로그래밍>

- 람다(lambda) 계산법

### 정수를 제곱하기

- 자바 프로그램은 가변 변수(mutable variable)를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다.
- 함수형 언어에서 변수는 변경되지 않는다.

### 불변성과 아키텍처

- 경합(race) 조건, 교착상태(deadlock) 조건, 동시 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생한다.
- 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.
- 아키텍트라면 동시성(concurrency) 문제에 지대한 관심을 가져야만 한다.

### 가변성의 분리

- 불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.
- 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
- 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.
- 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다는 것이다.
- 그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야한다.

### 이벤트 소싱

- 더 많은 메모리를 확보할수록, 기계가 더 빨라질수록, 필요한 가변 상태는 더 적어진다.
- 이벤트 소싱(event sourcing)은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
- 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다.
- 또한 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.
- 저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다. → 소스 코드 버전 관리 시스템을 떠올리면 됨

### 결론

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
- 각 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다.
- 어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지는 않는다.
- 1946년 앨런 튜링이 전자식 컴퓨터에서 실행할 거의 최초의 코드를 작성할 때 사용한 소프트웨어 규칙과 지금의 소프트웨어의 규칙은 조금도 다르지 않다.
- 도구는 달라졌고 하드웨어도 변했지만, 소프트웨어의 핵심은 여전히 그대로다.
- 소프트웨어, 즉 컴퓨터 프로그램은 순차(sequence), 분기(selection), 반복(iteration), 참조(indirection)로 구성된다.
- 그 이상도 이하도 아니다.
