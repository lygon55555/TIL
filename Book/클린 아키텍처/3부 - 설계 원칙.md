# 3부 - 설계 원칙

- 좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로부터 시작한다. 좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요 → SOLID
- SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.
- SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
    - 변경에 유연하다.
    - 이해하기 쉽다.
    - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
- ‘중간 수준’이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.  
즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.
- SRP: 단일 책임 원칙(Single Responsibility Principle)  
각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
- OCP: 개방∙폐쇄 원칙(Open-Closed Principle)  
기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다는 것이 이 원칙의 요지다.
- LSP: 리스코프 치환 원칙(Liskov Substitution Principle)  
상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.
- ISP: 인터페이스 분리 원칙(Interface Segregation Principle)  
사용하지 않은 것에 의존하지 않아야 한다.
- DIP: 의존성 역전 원칙(Dependency Inversion Principle)  
고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다.
- 이들 원칙이 아키텍처 관점에서 지닌 의미에 집중

# <7장 – SRP: 단일 책임 원칙>

- 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙.  
이 원칙은 커다란 함수를 작은 함수들로 리팩토링하는 더 저수준에서 사용된다.  
이 원칙은 SOLID 원칙이 아니며, SRP도 아니라서 헷갈리면 안 됨
- 역사적으로 SRP는 아래와 같이 기술되어 왔다.  
“단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.”
- 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.  
SRP가 말하는 ‘변경의 이유’란 바로 이들 사용자와 이해관계자를 가리킨다.  
SRP는 아래와 같이 바꿔 말할 수도 있다.  
“하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.”
- 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자가 두 명 이상일 수도 있다.  
해당 변경을 요청하는 한 명 이상의 사람들 → 이러한 집단을 액터(actor)라고 부르겠다.  
SRP의 최종 버전은 아래와 같아.  
“하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.”
- ‘모듈’의 가장 단순한 정의는 바로 소스 파일이다.  
일부 언어와 개발 환경에서는 코드를 소스 파일에 저장하지 않는데 이러한 경우 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.
- ‘응집된(cohesive)’이라는 단어가 SRP를 암시한다.  
단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성(cohesion)이다.

## 징후 1: 우발적 중복

- Emplyoee 클래스는 세 가지 메서드 calculatePay(), reportHours(), save()를 가진다.
- 이 클래스는 SRP를 위반하는데, 이들 세 가지 메서드가 서로 매우 다른 세 명의 액터를 책임지기 때문이다.
- calculatePay() 메서드와 reportHours() 메소드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 해보자.
- 그리고 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours()라는 메서드에 넣었다고 해보자.
- 어느 한 쪽에서 regularHours() 메서드를 변경해버리면 다른 쪽에서 문제가 잘못된 결과가 발생할 수 있다. → 이러한 문제는 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다. SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

## 징후 2: 병합

- 두 명의 서로 다른 개발자가, 그리고 아마도 서로 다른 팀에 속했을 두 개발자가 Employee 클래스를 체크아웃 받은 후 변경사항을 적용하기 시작한다. 안타깝게도 이들 변경사항은 서로 충돌한다. → 결과적으로 병합이 발생한다.
- 이들 징후는 모두 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 해당한다.
- 이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.

## 해결책

- 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다.
- 즉, 아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스(PayCalculator, HourReporter, EmployeeSaver)가 공유하도록 한다.
- 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함한다.
- 퍼사드(Facade) 패턴
- EmployeeFacade 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.
- 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식
- 가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있다.
- 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다.
- 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구(private 멤버)가 있는지를 전혀 알 수 없다.

## 결론

- 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.
- 컴포넌트 수준에서는 공통 폐쇄 원칙(Common Closure Principle)이 된다.
- 아키텍처 수준에서는 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)이 된다.

# <8장 – OCP: 개방-폐쇄 원칙>

- “소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.”
- 요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨린 것이다.

## 사고 실험

- 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙 SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙 DIP) 변경량을 최소화할 수 있다.
- 예를 들어, 재무제표를 웹 페이지로 보여주는 시스템이 있다고 생각해보자. 
이해관계자가 동일한 정보를 보고서 형태로 변환해서 흑백 프린터로 출력해 달라고 요청했다고 해보자.
- 어떻게 하면 될까?  
→ 재무 데이터 → 재무 분석기 → 보고서용 재무 데이터  
→ 두 가지의 보고서 생성 절차(보고서를 웹에 표시, 보고서를 프린터로 출력)  
여기서 얻을 수 있는 가장 중요한 영감은 보고서 생성이 두 개의 책임으로 분리된다는 사실이다.
- 위처럼 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다.
- 또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.
- 이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고 이들 클래스를 책 76쪽의 그림 2에서 이중선으로 표시한 컴포넌트 단위로 구분해야 한다.
- 화살표가 A 클래스에서 B 클래스로 향한다면, A 클래스에서는 B 클래스를 호출하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않는다.
- 책 77쪽의 그림 3에서 보듯, 모든 컴포넌트 관계는 단방향으로 이루어진다.  
이들 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.
- A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.
- 책 77쪽의 그림 3에서 왜 Interactor가 이처럼 특별한 위치를 차지해야만 하는가?  
Interactor 이외의 컴포넌트는 모두 주변적인 문제를 처리한다.  
가장 중요한 문제는 Interactor가 담당한다.
- 보호의 계층구조가 ‘수준(level)’이라는 개념을 바탕으로 어떻게 생성되는지 주목하자.  
Interactor는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다.  
View는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다.  
Presenter는 View보다는 높고 Controller나 Interactor보다는 낮은 수준에 위치한다.
- 아키텍트는 기능이 어떻게(how), 왜(why), 언제(when) 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.
- 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

## 방향성 제어

- 책 76쪽의 그림 2에서 FinancialDataGateway 인터페이스는 FinancialReportGenerator와 FinancialDataMapper 사이에 위치하는데, 이는 의존성을 역전시키기 위해서다.
- FinancialDataGateway 인터페이스가 없었다면, 의존성이 Interactor 컴포넌트에서 Database 컴포넌트로 바로 향하게 된다.
- FinancialReportPresenter 인터페이스와 2개의 View 인터페이스도 같은 목적을 가진다.

## 정보 은닉

- FinancialReportRequester 인터페이스는 FinancialReportController가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다.
- 만약 이 인터페이스가 없었다면, Controller는 FinancialEntities에 대해 추이 종속성(transitive dependency)을 가지게 된다.
- 클래스 A가 클래스 B에 의존하고, 다시 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존하게 된다. → 이를 추이 종속성이라고 부른다. 만약 클래스 의존성이 순환적(cyclic)이라면, 모든 클래스가 서로 의존하게 되는 문제가 있다.
- 추이 종속성을 가지게 되면, 소프트웨어 엔티티는 ‘자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다’는 소프트웨어 원칙을 위반하게 된다.

## 결론

- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.
- 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

# <9장 – LSP: 리스코프 치환 원칙>

- 바바라 리스코프(Barbara Liskov)는 하위 타입(subtype)을 아래와 같이 정의했다.  
“여기에서 필요한 것은 다음과 같은 치환(substitution) 원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.”

## 상속을 사용하도록 가이드하기

- 책 82쪽의 그림 1의 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다.

## 정사각형/직사각형 문제

- If문 등을 이용해서 LSP 위반을 막는 방법은 User의 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.

## LSP 위배 사례

- 책 84~86쪽 참고

## 결론

- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.
- 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

# <10장 – ISP: 인터페이스 분리 원칙>

- OPS 클래스에는 op1, op2, op3 오퍼레이션이 있다.  
User1은 오직 op1을, User2는 op2만을, User3는 op3만을 사용한다고 가정해보자.  
그리고 OPS가 정적 타입 언어로 작성된 클래스라고 해보자.
- 이 경우 User1에서는 op2와 op3를 전혀 사용하지 않음에도 User1의 소스 코드는 이 두 메서드에 의존하게 된다.
- 이러한 의존성으로 인해 OPS 클래스에서 op2의 소스 코드가 변경되면 User1과 관련된 코드가 아님에도 불구하고 User1도 다시 컴파일한 후 새로 배포해야 한다.  
→ 이러한 문제는 오퍼레이션을 인터페이스 단위로 분리하여 해결할 수 있다.

## ISP와 언어

- 정적 타입 언어는 사용자가 import, use 또는 include와 같은 타입 선언문을 사용하도록 강제한다.
- 이처럼 소스 코드에 ‘포함된(included)’ 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.
- 루비나 파이썬과 같은 동적 타입 언어에서는 소스 코드에 이러한 선언문이 존재하지 않는다.
- 대신 런타임에 추론이 발생한다.
- 따라서 소스 코드 의존성이 아예 없으며, 결국 재컴파일과 재배포가 필요없다.

## ISP와 아키텍처

- 필요 이상으로 많은 걸 포함하는 모듈에 의존한는 것은 해로운 일이다.
- 소스 코드 의존성의 경우 불필요한 재컴파일과 재배포를 강제한다.

## 결론

- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.
- 13장 “컴포넌트 응집도”에서 공통 재사용 원칙에서 더 자세히 다룸

# <11장 – DIP: 의존성 역전 원칙>

- 의존성 역전 원칙(DIP)에서 말하는 ‘유연성이 극대화된 시스템’이란 소스 코드 의존성이 추상(abstraction)에 의존하며 규제(concretion)에는 의존하지 않는 시스템이다.
- 위 말은 정적 타입 언어에서 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다.  
구체적인 대상에는 절대로 의존해서는 안 된다.
- 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소다. 
그리고 이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 변경될 수밖에 없는 모듈들이다.

## 안정된 추상화

- 추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다.
- 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 항상, 좀 더 정확히 말하면 대다수의 경우 변경될 필요가 없다.
- 따라서 인터페이스는 구현체보다 변동성이 낮다.
- 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처란 뜻이다.
- 이 원칙에서 전달하려는 내용은 아래와 같은 매우 구체적인 코딩 실천법으로 요약
    - 변동성이 큰 구체 클래스를 참조하지 말라.  
    대신 추상 인터페이스를 참조하라.
    - 변동성이 큰 구체 클래스로부터 파생하지 말라.  
    상속은 아주 신중하게 사용해야 한다.
    - 구체 함수를 오버라이드 하지 말라.  
    구체 함수는 대체로 소스 코드 의존성을 필요로 하고 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.
    - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

## 팩토리

- 위 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다.
- 왜냐하면 모든 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생하기 때문이다.
- 이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.
- 추상 팩토리를 사용한 구조는 책 94쪽 그림 1 참고
- 책 94쪽 그림 1의 곡선은 아키텍처 경계를 뜻한다.
소스 코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.
- 곡선은 시스템을 두 가지 컴포넌트로 분리한다.
- 하나는 추상 컴포넌트이며, 다른 하나는 구체 컴포넌트다.
- 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다.
- 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.
- 제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다.
- 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다.  
→ 의존성 역전(Dependency Inversion)이라고 불리는 이유

## 구체 컴포넌트

- DIP 위배를 모두 없앨 수는 없다.
- 하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.
- main 함수를 포함하는 컴포넌트는 흔히 메인(Main)이라고 부름

## 결론

- 책 94쪽 그림 1의 곡선은 이후의 장에서는 아키텍처 경계가 될 것이다.
- 그리고 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다.
- 추후 이 규칙은 의존성 규칙(Dependency Rule)이라 부를 것이다.
